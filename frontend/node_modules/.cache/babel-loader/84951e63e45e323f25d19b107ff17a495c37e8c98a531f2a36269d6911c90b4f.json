{"ast":null,"code":"/*\n * buffered-stream.js: A simple(r) Stream which is partially buffered into memory.\n *\n * (C) 2010, Mikeal Rogers\n *\n * Adapted for Flatiron\n * (C) 2011, Charlie Robbins & the Contributors\n * MIT LICENSE\n *\n */\n\nvar events = require('events'),\n  fs = require('fs'),\n  stream = require('stream'),\n  util = require('util');\n\n//\n// ### function BufferedStream (limit)\n// #### @limit {number} **Optional** Size of the buffer to limit\n// Constructor function for the BufferedStream object responsible for\n// maintaining a stream interface which can also persist to memory\n// temporarily.\n//\n\nvar BufferedStream = module.exports = function (limit) {\n  events.EventEmitter.call(this);\n  if (typeof limit === 'undefined') {\n    limit = Infinity;\n  }\n  this.limit = limit;\n  this.size = 0;\n  this.chunks = [];\n  this.writable = true;\n  this.readable = true;\n  this._buffer = true;\n};\nutil.inherits(BufferedStream, stream.Stream);\nObject.defineProperty(BufferedStream.prototype, 'buffer', {\n  get: function () {\n    return this._buffer;\n  },\n  set: function (value) {\n    if (!value && this.chunks) {\n      var self = this;\n      this.chunks.forEach(function (c) {\n        self.emit('data', c);\n      });\n      if (this.ended) this.emit('end');\n      this.size = 0;\n      delete this.chunks;\n    }\n    this._buffer = value;\n  }\n});\nBufferedStream.prototype.pipe = function () {\n  var self = this,\n    dest;\n  if (self.resume) {\n    self.resume();\n  }\n  dest = stream.Stream.prototype.pipe.apply(self, arguments);\n\n  //\n  // just incase you are piping to two streams, do not emit data twice.\n  // note: you can pipe twice, but you need to pipe both streams in the same tick.\n  // (this is normal for streams)\n  //\n  if (this.piped) {\n    return dest;\n  }\n  process.nextTick(function () {\n    if (self.chunks) {\n      self.chunks.forEach(function (c) {\n        self.emit('data', c);\n      });\n      self.size = 0;\n      delete self.chunks;\n    }\n    if (!self.readable) {\n      if (self.ended) {\n        self.emit('end');\n      } else if (self.closed) {\n        self.emit('close');\n      }\n    }\n  });\n  this.piped = true;\n  return dest;\n};\nBufferedStream.prototype.write = function (chunk) {\n  if (!this.chunks || this.piped) {\n    this.emit('data', chunk);\n    return;\n  }\n  this.chunks.push(chunk);\n  this.size += chunk.length;\n  if (this.limit < this.size) {\n    this.pause();\n  }\n};\nBufferedStream.prototype.end = function () {\n  this.readable = false;\n  this.ended = true;\n  this.emit('end');\n};\nBufferedStream.prototype.destroy = function () {\n  this.readable = false;\n  this.writable = false;\n  delete this.chunks;\n};\nBufferedStream.prototype.close = function () {\n  this.readable = false;\n  this.closed = true;\n};\nif (!stream.Stream.prototype.pause) {\n  BufferedStream.prototype.pause = function () {\n    this.emit('pause');\n  };\n}\nif (!stream.Stream.prototype.resume) {\n  BufferedStream.prototype.resume = function () {\n    this.emit('resume');\n  };\n}","map":{"version":3,"names":["events","require","fs","stream","util","BufferedStream","module","exports","limit","EventEmitter","call","Infinity","size","chunks","writable","readable","_buffer","inherits","Stream","Object","defineProperty","prototype","get","set","value","self","forEach","c","emit","ended","pipe","dest","resume","apply","arguments","piped","process","nextTick","closed","write","chunk","push","length","pause","end","destroy","close"],"sources":["/Users/juancvegao/Documents/PROGRAMMING/REACT/ejerciciosUniversidad/notes_github/frontend/node_modules/union/lib/buffered-stream.js"],"sourcesContent":["/*\n * buffered-stream.js: A simple(r) Stream which is partially buffered into memory.\n *\n * (C) 2010, Mikeal Rogers\n *\n * Adapted for Flatiron\n * (C) 2011, Charlie Robbins & the Contributors\n * MIT LICENSE\n *\n */\n\nvar events = require('events'),\n    fs = require('fs'),\n    stream = require('stream'),\n    util = require('util');\n\n//\n// ### function BufferedStream (limit)\n// #### @limit {number} **Optional** Size of the buffer to limit\n// Constructor function for the BufferedStream object responsible for\n// maintaining a stream interface which can also persist to memory\n// temporarily.\n//\n\nvar BufferedStream = module.exports = function (limit) {\n  events.EventEmitter.call(this);\n\n  if (typeof limit === 'undefined') {\n    limit = Infinity;\n  }\n\n  this.limit = limit;\n  this.size = 0;\n  this.chunks = [];\n  this.writable = true;\n  this.readable = true;\n  this._buffer = true;\n};\n\nutil.inherits(BufferedStream, stream.Stream);\n\nObject.defineProperty(BufferedStream.prototype, 'buffer', {\n  get: function () {\n    return this._buffer;\n  },\n  set: function (value) {\n    if (!value && this.chunks) {\n      var self = this;\n      this.chunks.forEach(function (c) { self.emit('data', c) });\n      if (this.ended) this.emit('end');\n      this.size = 0;\n      delete this.chunks;\n    }\n\n    this._buffer = value;\n  }\n});\n\nBufferedStream.prototype.pipe = function () {\n  var self = this,\n      dest;\n\n  if (self.resume) {\n    self.resume();\n  }\n\n  dest = stream.Stream.prototype.pipe.apply(self, arguments);\n\n  //\n  // just incase you are piping to two streams, do not emit data twice.\n  // note: you can pipe twice, but you need to pipe both streams in the same tick.\n  // (this is normal for streams)\n  //\n  if (this.piped) {\n    return dest;\n  }\n\n  process.nextTick(function () {\n    if (self.chunks) {\n      self.chunks.forEach(function (c) { self.emit('data', c) });\n      self.size = 0;\n      delete self.chunks;\n    }\n\n    if (!self.readable) {\n      if (self.ended) {\n        self.emit('end');\n      }\n      else if (self.closed) {\n        self.emit('close');\n      }\n    }\n  });\n\n  this.piped = true;\n\n  return dest;\n};\n\nBufferedStream.prototype.write = function (chunk) {\n  if (!this.chunks || this.piped) {\n    this.emit('data', chunk);\n    return;\n  }\n\n  this.chunks.push(chunk);\n  this.size += chunk.length;\n  if (this.limit < this.size) {\n    this.pause();\n  }\n};\n\nBufferedStream.prototype.end = function () {\n  this.readable = false;\n  this.ended = true;\n  this.emit('end');\n};\n\nBufferedStream.prototype.destroy = function () {\n  this.readable = false;\n  this.writable = false;\n  delete this.chunks;\n};\n\nBufferedStream.prototype.close = function () {\n  this.readable = false;\n  this.closed = true;\n};\n\nif (!stream.Stream.prototype.pause) {\n  BufferedStream.prototype.pause = function () {\n    this.emit('pause');\n  };\n}\n\nif (!stream.Stream.prototype.resume) {\n  BufferedStream.prototype.resume = function () {\n    this.emit('resume');\n  };\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}