{"ast":null,"code":"'use strict';\n\nvar transport = require('../spdy-transport');\nvar assert = require('assert');\nvar util = require('util');\nvar debug = {\n  client: require('debug')('spdy:stream:client'),\n  server: require('debug')('spdy:stream:server')\n};\nvar Duplex = require('readable-stream').Duplex;\nfunction Stream(connection, options) {\n  Duplex.call(this);\n  var connectionState = connection._spdyState;\n  var state = {};\n  this._spdyState = state;\n  this.id = options.id;\n  this.method = options.method;\n  this.path = options.path;\n  this.host = options.host;\n  this.headers = options.headers || {};\n  this.connection = connection;\n  this.parent = options.parent || null;\n  state.socket = null;\n  state.protocol = connectionState.protocol;\n  state.constants = state.protocol.constants;\n\n  // See _initPriority()\n  state.priority = null;\n  state.version = this.connection.getVersion();\n  state.isServer = this.connection.isServer();\n  state.debug = state.isServer ? debug.server : debug.client;\n  state.framer = connectionState.framer;\n  state.parser = connectionState.parser;\n  state.request = options.request;\n  state.needResponse = options.request;\n  state.window = connectionState.streamWindow.clone(options.id);\n  state.sessionWindow = connectionState.window;\n  state.maxChunk = connectionState.maxChunk;\n\n  // Can't send incoming request\n  // (See `.send()` method)\n  state.sent = !state.request;\n  state.readable = options.readable !== false;\n  state.writable = options.writable !== false;\n  state.aborted = false;\n  state.corked = 0;\n  state.corkQueue = [];\n  state.timeout = new transport.utils.Timeout(this);\n  this.on('finish', this._onFinish);\n  this.on('end', this._onEnd);\n  var self = this;\n  function _onWindowOverflow() {\n    self._onWindowOverflow();\n  }\n  state.window.recv.on('overflow', _onWindowOverflow);\n  state.window.send.on('overflow', _onWindowOverflow);\n  this._initPriority(options.priority);\n  if (!state.readable) {\n    this.push(null);\n  }\n  if (!state.writable) {\n    this._writableState.ended = true;\n    this._writableState.finished = true;\n  }\n}\nutil.inherits(Stream, Duplex);\nexports.Stream = Stream;\nStream.prototype._init = function _init(socket) {\n  this.socket = socket;\n};\nStream.prototype._initPriority = function _initPriority(priority) {\n  var state = this._spdyState;\n  var connectionState = this.connection._spdyState;\n  var root = connectionState.priorityRoot;\n  if (!priority) {\n    state.priority = root.addDefault(this.id);\n    return;\n  }\n  state.priority = root.add({\n    id: this.id,\n    parent: priority.parent,\n    weight: priority.weight,\n    exclusive: priority.exclusive\n  });\n};\nStream.prototype._handleFrame = function _handleFrame(frame) {\n  var state = this._spdyState;\n\n  // Ignore any kind of data after abort\n  if (state.aborted) {\n    state.debug('id=%d ignoring frame=%s after abort', this.id, frame.type);\n    return;\n  }\n\n  // Restart the timer on incoming frames\n  state.timeout.reset();\n  if (frame.type === 'DATA') {\n    this._handleData(frame);\n  } else if (frame.type === 'HEADERS') {\n    this._handleHeaders(frame);\n  } else if (frame.type === 'RST') {\n    this._handleRST(frame);\n  } else if (frame.type === 'WINDOW_UPDATE') {\n    this._handleWindowUpdate(frame);\n  } else if (frame.type === 'PRIORITY') {\n    this._handlePriority(frame);\n  } else if (frame.type === 'PUSH_PROMISE') {\n    this._handlePushPromise(frame);\n  }\n  if (frame.fin) {\n    state.debug('id=%d end', this.id);\n    this.push(null);\n  }\n};\nfunction checkAborted(stream, state, callback) {\n  if (state.aborted) {\n    state.debug('id=%d abort write', stream.id);\n    process.nextTick(function () {\n      callback(new Error('Stream write aborted'));\n    });\n    return true;\n  }\n  return false;\n}\nfunction _send(stream, state, data, callback) {\n  if (checkAborted(stream, state, callback)) {\n    return;\n  }\n  state.debug('id=%d presend=%d', stream.id, data.length);\n  state.timeout.reset();\n  state.window.send.update(-data.length, function () {\n    if (checkAborted(stream, state, callback)) {\n      return;\n    }\n    state.debug('id=%d send=%d', stream.id, data.length);\n    state.timeout.reset();\n    state.framer.dataFrame({\n      id: stream.id,\n      priority: state.priority.getPriority(),\n      fin: false,\n      data: data\n    }, function (err) {\n      state.debug('id=%d postsend=%d', stream.id, data.length);\n      callback(err);\n    });\n  });\n}\nStream.prototype._write = function _write(data, enc, callback) {\n  var state = this._spdyState;\n\n  // Send the request if it wasn't sent\n  if (!state.sent) {\n    this.send();\n  }\n\n  // Writes should come after pending control frames (response and headers)\n  if (state.corked !== 0) {\n    var self = this;\n    state.corkQueue.push(function () {\n      self._write(data, enc, callback);\n    });\n    return;\n  }\n\n  // Split DATA in chunks to prevent window from going negative\n  this._splitStart(data, _send, callback);\n};\nStream.prototype._splitStart = function _splitStart(data, onChunk, callback) {\n  return this._split(data, 0, onChunk, callback);\n};\nStream.prototype._split = function _split(data, offset, onChunk, callback) {\n  if (offset === data.length) {\n    return process.nextTick(callback);\n  }\n  var state = this._spdyState;\n  var local = state.window.send;\n  var session = state.sessionWindow.send;\n  var availSession = Math.max(0, session.getCurrent());\n  if (availSession === 0) {\n    availSession = session.getMax();\n  }\n  var availLocal = Math.max(0, local.getCurrent());\n  if (availLocal === 0) {\n    availLocal = local.getMax();\n  }\n  var avail = Math.min(availSession, availLocal);\n  avail = Math.min(avail, state.maxChunk);\n  var self = this;\n  if (avail === 0) {\n    state.window.send.update(0, function () {\n      self._split(data, offset, onChunk, callback);\n    });\n    return;\n  }\n\n  // Split data in chunks in a following way:\n  var limit = avail;\n  var size = Math.min(data.length - offset, limit);\n  var chunk = data.slice(offset, offset + size);\n  onChunk(this, state, chunk, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    // Get the next chunk\n    self._split(data, offset + size, onChunk, callback);\n  });\n};\nStream.prototype._read = function _read() {\n  var state = this._spdyState;\n  if (!state.window.recv.isDraining()) {\n    return;\n  }\n  var delta = state.window.recv.getDelta();\n  state.debug('id=%d window emptying, update by %d', this.id, delta);\n  state.window.recv.update(delta);\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  });\n};\nStream.prototype._handleData = function _handleData(frame) {\n  var state = this._spdyState;\n\n  // DATA on ended or not readable stream!\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({\n      id: this.id,\n      code: 'STREAM_CLOSED'\n    });\n    return;\n  }\n  state.debug('id=%d recv=%d', this.id, frame.data.length);\n  state.window.recv.update(-frame.data.length);\n  this.push(frame.data);\n};\nStream.prototype._handleRST = function _handleRST(frame) {\n  if (frame.code !== 'CANCEL') {\n    this.emit('error', new Error('Got RST: ' + frame.code));\n  }\n  this.abort();\n};\nStream.prototype._handleWindowUpdate = function _handleWindowUpdate(frame) {\n  var state = this._spdyState;\n  state.window.send.update(frame.delta);\n};\nStream.prototype._onWindowOverflow = function _onWindowOverflow() {\n  var state = this._spdyState;\n  state.debug('id=%d window overflow', this.id);\n  state.framer.rstFrame({\n    id: this.id,\n    code: 'FLOW_CONTROL_ERROR'\n  });\n  this.aborted = true;\n  this.emit('error', new Error('HTTP2 window overflow'));\n};\nStream.prototype._handlePriority = function _handlePriority(frame) {\n  var state = this._spdyState;\n  state.priority.remove();\n  state.priority = null;\n  this._initPriority(frame.priority);\n\n  // Mostly for testing purposes\n  this.emit('priority', frame.priority);\n};\nStream.prototype._handleHeaders = function _handleHeaders(frame) {\n  var state = this._spdyState;\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({\n      id: this.id,\n      code: 'STREAM_CLOSED'\n    });\n    return;\n  }\n  if (state.needResponse) {\n    return this._handleResponse(frame);\n  }\n  this.emit('headers', frame.headers);\n};\nStream.prototype._handleResponse = function _handleResponse(frame) {\n  var state = this._spdyState;\n  if (frame.headers[':status'] === undefined) {\n    state.framer.rstFrame({\n      id: this.id,\n      code: 'PROTOCOL_ERROR'\n    });\n    return;\n  }\n  state.needResponse = false;\n  this.emit('response', frame.headers[':status'] | 0, frame.headers);\n};\nStream.prototype._onFinish = function _onFinish() {\n  var state = this._spdyState;\n\n  // Send the request if it wasn't sent\n  if (!state.sent) {\n    // NOTE: will send HEADERS with FIN flag\n    this.send();\n  } else {\n    // Just an `.end()` without any writes will trigger immediate `finish` event\n    // without any calls to `_write()`.\n    if (state.corked !== 0) {\n      var self = this;\n      state.corkQueue.push(function () {\n        self._onFinish();\n      });\n      return;\n    }\n    state.framer.dataFrame({\n      id: this.id,\n      priority: state.priority.getPriority(),\n      fin: true,\n      data: Buffer.alloc(0)\n    });\n  }\n  this._maybeClose();\n};\nStream.prototype._onEnd = function _onEnd() {\n  this._maybeClose();\n};\nStream.prototype._checkEnded = function _checkEnded(callback) {\n  var state = this._spdyState;\n  var ended = false;\n  if (state.aborted) {\n    ended = true;\n  }\n  if (!state.writable || this._writableState.finished) {\n    ended = true;\n  }\n  if (!ended) {\n    return true;\n  }\n  if (!callback) {\n    return false;\n  }\n  var err = new Error('Ended stream can\\'t send frames');\n  process.nextTick(function () {\n    callback(err);\n  });\n  return false;\n};\nStream.prototype._maybeClose = function _maybeClose() {\n  var state = this._spdyState;\n\n  // .abort() emits `close`\n  if (state.aborted) {\n    return;\n  }\n  if ((!state.readable || this._readableState.ended) && this._writableState.finished) {\n    // Clear timeout\n    state.timeout.set(0);\n    this.emit('close');\n  }\n};\nStream.prototype._handlePushPromise = function _handlePushPromise(frame) {\n  var push = this.connection._createStream({\n    id: frame.promisedId,\n    parent: this,\n    push: true,\n    request: true,\n    method: frame.headers[':method'],\n    path: frame.headers[':path'],\n    host: frame.headers[':authority'],\n    priority: frame.priority,\n    headers: frame.headers,\n    writable: false\n  });\n\n  // GOAWAY\n  if (this.connection._isGoaway(push.id)) {\n    return;\n  }\n  if (!this.emit('pushPromise', push)) {\n    push.abort();\n  }\n};\nStream.prototype._hardCork = function _hardCork() {\n  var state = this._spdyState;\n  this.cork();\n  state.corked++;\n};\nStream.prototype._hardUncork = function _hardUncork() {\n  var state = this._spdyState;\n  this.uncork();\n  state.corked--;\n  if (state.corked !== 0) {\n    return;\n  }\n\n  // Invoke callbacks\n  var queue = state.corkQueue;\n  state.corkQueue = [];\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n};\nStream.prototype._sendPush = function _sendPush(status, response, callback) {\n  var self = this;\n  var state = this._spdyState;\n  this._hardCork();\n  state.framer.pushFrame({\n    id: this.parent.id,\n    promisedId: this.id,\n    priority: state.priority.toJSON(),\n    path: this.path,\n    host: this.host,\n    method: this.method,\n    status: status,\n    headers: this.headers,\n    response: response\n  }, function (err) {\n    self._hardUncork();\n    callback(err);\n  });\n};\nStream.prototype._wasSent = function _wasSent() {\n  var state = this._spdyState;\n  return state.sent;\n};\n\n// Public API\n\nStream.prototype.send = function send(callback) {\n  var state = this._spdyState;\n  if (state.sent) {\n    var err = new Error('Stream was already sent');\n    process.nextTick(function () {\n      if (callback) {\n        callback(err);\n      }\n    });\n    return;\n  }\n  state.sent = true;\n  state.timeout.reset();\n\n  // GET requests should always be auto-finished\n  if (this.method === 'GET') {\n    this._writableState.ended = true;\n    this._writableState.finished = true;\n  }\n\n  // TODO(indunty): ideally it should just take a stream object as an input\n  var self = this;\n  this._hardCork();\n  state.framer.requestFrame({\n    id: this.id,\n    method: this.method,\n    path: this.path,\n    host: this.host,\n    priority: state.priority.toJSON(),\n    headers: this.headers,\n    fin: this._writableState.finished\n  }, function (err) {\n    self._hardUncork();\n    if (!callback) {\n      return;\n    }\n    callback(err);\n  });\n};\nStream.prototype.respond = function respond(status, headers, callback) {\n  var self = this;\n  var state = this._spdyState;\n  assert(!state.request, 'Can\\'t respond on request');\n  state.timeout.reset();\n  if (!this._checkEnded(callback)) {\n    return;\n  }\n  var frame = {\n    id: this.id,\n    status: status,\n    headers: headers\n  };\n  this._hardCork();\n  state.framer.responseFrame(frame, function (err) {\n    self._hardUncork();\n    if (callback) {\n      callback(err);\n    }\n  });\n};\nStream.prototype.setWindow = function setWindow(size) {\n  var state = this._spdyState;\n  state.timeout.reset();\n  if (!this._checkEnded()) {\n    return;\n  }\n  state.debug('id=%d force window max=%d', this.id, size);\n  state.window.recv.setMax(size);\n  var delta = state.window.recv.getDelta();\n  if (delta === 0) {\n    return;\n  }\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  });\n  state.window.recv.update(delta);\n};\nStream.prototype.sendHeaders = function sendHeaders(headers, callback) {\n  var self = this;\n  var state = this._spdyState;\n  state.timeout.reset();\n  if (!this._checkEnded(callback)) {\n    return;\n  }\n\n  // Request wasn't yet send, coalesce headers\n  if (!state.sent) {\n    this.headers = Object.assign({}, this.headers);\n    Object.assign(this.headers, headers);\n    process.nextTick(function () {\n      if (callback) {\n        callback(null);\n      }\n    });\n    return;\n  }\n  this._hardCork();\n  state.framer.headersFrame({\n    id: this.id,\n    headers: headers\n  }, function (err) {\n    self._hardUncork();\n    if (callback) {\n      callback(err);\n    }\n  });\n};\nStream.prototype._destroy = function destroy() {\n  this.abort();\n};\nStream.prototype.abort = function abort(code, callback) {\n  var state = this._spdyState;\n\n  // .abort(callback)\n  if (typeof code === 'function') {\n    callback = code;\n    code = null;\n  }\n  if (this._readableState.ended && this._writableState.finished) {\n    state.debug('id=%d already closed', this.id);\n    if (callback) {\n      process.nextTick(callback);\n    }\n    return;\n  }\n  if (state.aborted) {\n    state.debug('id=%d already aborted', this.id);\n    if (callback) {\n      process.nextTick(callback);\n    }\n    return;\n  }\n  state.aborted = true;\n  state.debug('id=%d abort', this.id);\n  this.setTimeout(0);\n  var abortCode = code || 'CANCEL';\n  state.framer.rstFrame({\n    id: this.id,\n    code: abortCode\n  });\n  var self = this;\n  process.nextTick(function () {\n    if (callback) {\n      callback(null);\n    }\n    self.emit('close', new Error('Aborted, code: ' + abortCode));\n  });\n};\nStream.prototype.setPriority = function setPriority(info) {\n  var state = this._spdyState;\n  state.timeout.reset();\n  if (!this._checkEnded()) {\n    return;\n  }\n  state.debug('id=%d priority change', this.id, info);\n  var frame = {\n    id: this.id,\n    priority: info\n  };\n\n  // Change priority on this side\n  this._handlePriority(frame);\n\n  // And on the other too\n  state.framer.priorityFrame(frame);\n};\nStream.prototype.pushPromise = function pushPromise(uri, callback) {\n  if (!this._checkEnded(callback)) {\n    return;\n  }\n  var self = this;\n  this._hardCork();\n  var push = this.connection.pushPromise(this, uri, function (err) {\n    self._hardUncork();\n    if (!err) {\n      push._hardUncork();\n    }\n    if (callback) {\n      return callback(err, push);\n    }\n    if (err) {\n      push.emit('error', err);\n    }\n  });\n  push._hardCork();\n  return push;\n};\nStream.prototype.setMaxChunk = function setMaxChunk(size) {\n  var state = this._spdyState;\n  state.maxChunk = size;\n};\nStream.prototype.setTimeout = function setTimeout(delay, callback) {\n  var state = this._spdyState;\n  state.timeout.set(delay, callback);\n};","map":{"version":3,"names":["transport","require","assert","util","debug","client","server","Duplex","Stream","connection","options","call","connectionState","_spdyState","state","id","method","path","host","headers","parent","socket","protocol","constants","priority","version","getVersion","isServer","framer","parser","request","needResponse","window","streamWindow","clone","sessionWindow","maxChunk","sent","readable","writable","aborted","corked","corkQueue","timeout","utils","Timeout","on","_onFinish","_onEnd","self","_onWindowOverflow","recv","send","_initPriority","push","_writableState","ended","finished","inherits","exports","prototype","_init","root","priorityRoot","addDefault","add","weight","exclusive","_handleFrame","frame","type","reset","_handleData","_handleHeaders","_handleRST","_handleWindowUpdate","_handlePriority","_handlePushPromise","fin","checkAborted","stream","callback","process","nextTick","Error","_send","data","length","update","dataFrame","getPriority","err","_write","enc","_splitStart","onChunk","_split","offset","local","session","availSession","Math","max","getCurrent","getMax","availLocal","avail","min","limit","size","chunk","slice","_read","isDraining","delta","getDelta","windowUpdateFrame","_readableState","rstFrame","code","emit","abort","remove","_handleResponse","undefined","Buffer","alloc","_maybeClose","_checkEnded","set","_createStream","promisedId","_isGoaway","_hardCork","cork","_hardUncork","uncork","queue","i","_sendPush","status","response","pushFrame","toJSON","_wasSent","requestFrame","respond","responseFrame","setWindow","setMax","sendHeaders","Object","assign","headersFrame","_destroy","destroy","setTimeout","abortCode","setPriority","info","priorityFrame","pushPromise","uri","setMaxChunk","delay"],"sources":["/Users/juancvegao/Documents/PROGRAMMING/REACT/ejerciciosUniversidad/notes_github/frontend/node_modules/spdy-transport/lib/spdy-transport/stream.js"],"sourcesContent":["'use strict'\n\nvar transport = require('../spdy-transport')\n\nvar assert = require('assert')\nvar util = require('util')\n\nvar debug = {\n  client: require('debug')('spdy:stream:client'),\n  server: require('debug')('spdy:stream:server')\n}\nvar Duplex = require('readable-stream').Duplex\n\nfunction Stream (connection, options) {\n  Duplex.call(this)\n\n  var connectionState = connection._spdyState\n\n  var state = {}\n  this._spdyState = state\n\n  this.id = options.id\n  this.method = options.method\n  this.path = options.path\n  this.host = options.host\n  this.headers = options.headers || {}\n  this.connection = connection\n  this.parent = options.parent || null\n\n  state.socket = null\n  state.protocol = connectionState.protocol\n  state.constants = state.protocol.constants\n\n  // See _initPriority()\n  state.priority = null\n\n  state.version = this.connection.getVersion()\n  state.isServer = this.connection.isServer()\n  state.debug = state.isServer ? debug.server : debug.client\n\n  state.framer = connectionState.framer\n  state.parser = connectionState.parser\n\n  state.request = options.request\n  state.needResponse = options.request\n  state.window = connectionState.streamWindow.clone(options.id)\n  state.sessionWindow = connectionState.window\n  state.maxChunk = connectionState.maxChunk\n\n  // Can't send incoming request\n  // (See `.send()` method)\n  state.sent = !state.request\n\n  state.readable = options.readable !== false\n  state.writable = options.writable !== false\n\n  state.aborted = false\n\n  state.corked = 0\n  state.corkQueue = []\n\n  state.timeout = new transport.utils.Timeout(this)\n\n  this.on('finish', this._onFinish)\n  this.on('end', this._onEnd)\n\n  var self = this\n  function _onWindowOverflow () {\n    self._onWindowOverflow()\n  }\n\n  state.window.recv.on('overflow', _onWindowOverflow)\n  state.window.send.on('overflow', _onWindowOverflow)\n\n  this._initPriority(options.priority)\n\n  if (!state.readable) { this.push(null) }\n  if (!state.writable) {\n    this._writableState.ended = true\n    this._writableState.finished = true\n  }\n}\nutil.inherits(Stream, Duplex)\nexports.Stream = Stream\n\nStream.prototype._init = function _init (socket) {\n  this.socket = socket\n}\n\nStream.prototype._initPriority = function _initPriority (priority) {\n  var state = this._spdyState\n  var connectionState = this.connection._spdyState\n  var root = connectionState.priorityRoot\n\n  if (!priority) {\n    state.priority = root.addDefault(this.id)\n    return\n  }\n\n  state.priority = root.add({\n    id: this.id,\n    parent: priority.parent,\n    weight: priority.weight,\n    exclusive: priority.exclusive\n  })\n}\n\nStream.prototype._handleFrame = function _handleFrame (frame) {\n  var state = this._spdyState\n\n  // Ignore any kind of data after abort\n  if (state.aborted) {\n    state.debug('id=%d ignoring frame=%s after abort', this.id, frame.type)\n    return\n  }\n\n  // Restart the timer on incoming frames\n  state.timeout.reset()\n\n  if (frame.type === 'DATA') {\n    this._handleData(frame)\n  } else if (frame.type === 'HEADERS') {\n    this._handleHeaders(frame)\n  } else if (frame.type === 'RST') {\n    this._handleRST(frame)\n  } else if (frame.type === 'WINDOW_UPDATE') { this._handleWindowUpdate(frame) } else if (frame.type === 'PRIORITY') {\n    this._handlePriority(frame)\n  } else if (frame.type === 'PUSH_PROMISE') { this._handlePushPromise(frame) }\n\n  if (frame.fin) {\n    state.debug('id=%d end', this.id)\n    this.push(null)\n  }\n}\n\nfunction checkAborted (stream, state, callback) {\n  if (state.aborted) {\n    state.debug('id=%d abort write', stream.id)\n    process.nextTick(function () {\n      callback(new Error('Stream write aborted'))\n    })\n    return true\n  }\n\n  return false\n}\n\nfunction _send (stream, state, data, callback) {\n  if (checkAborted(stream, state, callback)) {\n    return\n  }\n\n  state.debug('id=%d presend=%d', stream.id, data.length)\n\n  state.timeout.reset()\n\n  state.window.send.update(-data.length, function () {\n    if (checkAborted(stream, state, callback)) {\n      return\n    }\n\n    state.debug('id=%d send=%d', stream.id, data.length)\n\n    state.timeout.reset()\n\n    state.framer.dataFrame({\n      id: stream.id,\n      priority: state.priority.getPriority(),\n      fin: false,\n      data: data\n    }, function (err) {\n      state.debug('id=%d postsend=%d', stream.id, data.length)\n      callback(err)\n    })\n  })\n}\n\nStream.prototype._write = function _write (data, enc, callback) {\n  var state = this._spdyState\n\n  // Send the request if it wasn't sent\n  if (!state.sent) { this.send() }\n\n  // Writes should come after pending control frames (response and headers)\n  if (state.corked !== 0) {\n    var self = this\n    state.corkQueue.push(function () {\n      self._write(data, enc, callback)\n    })\n    return\n  }\n\n  // Split DATA in chunks to prevent window from going negative\n  this._splitStart(data, _send, callback)\n}\n\nStream.prototype._splitStart = function _splitStart (data, onChunk, callback) {\n  return this._split(data, 0, onChunk, callback)\n}\n\nStream.prototype._split = function _split (data, offset, onChunk, callback) {\n  if (offset === data.length) {\n    return process.nextTick(callback)\n  }\n\n  var state = this._spdyState\n  var local = state.window.send\n  var session = state.sessionWindow.send\n\n  var availSession = Math.max(0, session.getCurrent())\n  if (availSession === 0) {\n    availSession = session.getMax()\n  }\n  var availLocal = Math.max(0, local.getCurrent())\n  if (availLocal === 0) {\n    availLocal = local.getMax()\n  }\n\n  var avail = Math.min(availSession, availLocal)\n  avail = Math.min(avail, state.maxChunk)\n\n  var self = this\n\n  if (avail === 0) {\n    state.window.send.update(0, function () {\n      self._split(data, offset, onChunk, callback)\n    })\n    return\n  }\n\n  // Split data in chunks in a following way:\n  var limit = avail\n  var size = Math.min(data.length - offset, limit)\n\n  var chunk = data.slice(offset, offset + size)\n\n  onChunk(this, state, chunk, function (err) {\n    if (err) { return callback(err) }\n\n    // Get the next chunk\n    self._split(data, offset + size, onChunk, callback)\n  })\n}\n\nStream.prototype._read = function _read () {\n  var state = this._spdyState\n\n  if (!state.window.recv.isDraining()) {\n    return\n  }\n\n  var delta = state.window.recv.getDelta()\n\n  state.debug('id=%d window emptying, update by %d', this.id, delta)\n\n  state.window.recv.update(delta)\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  })\n}\n\nStream.prototype._handleData = function _handleData (frame) {\n  var state = this._spdyState\n\n  // DATA on ended or not readable stream!\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({ id: this.id, code: 'STREAM_CLOSED' })\n    return\n  }\n\n  state.debug('id=%d recv=%d', this.id, frame.data.length)\n  state.window.recv.update(-frame.data.length)\n\n  this.push(frame.data)\n}\n\nStream.prototype._handleRST = function _handleRST (frame) {\n  if (frame.code !== 'CANCEL') {\n    this.emit('error', new Error('Got RST: ' + frame.code))\n  }\n  this.abort()\n}\n\nStream.prototype._handleWindowUpdate = function _handleWindowUpdate (frame) {\n  var state = this._spdyState\n\n  state.window.send.update(frame.delta)\n}\n\nStream.prototype._onWindowOverflow = function _onWindowOverflow () {\n  var state = this._spdyState\n\n  state.debug('id=%d window overflow', this.id)\n  state.framer.rstFrame({ id: this.id, code: 'FLOW_CONTROL_ERROR' })\n\n  this.aborted = true\n  this.emit('error', new Error('HTTP2 window overflow'))\n}\n\nStream.prototype._handlePriority = function _handlePriority (frame) {\n  var state = this._spdyState\n\n  state.priority.remove()\n  state.priority = null\n  this._initPriority(frame.priority)\n\n  // Mostly for testing purposes\n  this.emit('priority', frame.priority)\n}\n\nStream.prototype._handleHeaders = function _handleHeaders (frame) {\n  var state = this._spdyState\n\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({ id: this.id, code: 'STREAM_CLOSED' })\n    return\n  }\n\n  if (state.needResponse) {\n    return this._handleResponse(frame)\n  }\n\n  this.emit('headers', frame.headers)\n}\n\nStream.prototype._handleResponse = function _handleResponse (frame) {\n  var state = this._spdyState\n\n  if (frame.headers[':status'] === undefined) {\n    state.framer.rstFrame({ id: this.id, code: 'PROTOCOL_ERROR' })\n    return\n  }\n\n  state.needResponse = false\n  this.emit('response', frame.headers[':status'] | 0, frame.headers)\n}\n\nStream.prototype._onFinish = function _onFinish () {\n  var state = this._spdyState\n\n  // Send the request if it wasn't sent\n  if (!state.sent) {\n    // NOTE: will send HEADERS with FIN flag\n    this.send()\n  } else {\n    // Just an `.end()` without any writes will trigger immediate `finish` event\n    // without any calls to `_write()`.\n    if (state.corked !== 0) {\n      var self = this\n      state.corkQueue.push(function () {\n        self._onFinish()\n      })\n      return\n    }\n\n    state.framer.dataFrame({\n      id: this.id,\n      priority: state.priority.getPriority(),\n      fin: true,\n      data: Buffer.alloc(0)\n    })\n  }\n\n  this._maybeClose()\n}\n\nStream.prototype._onEnd = function _onEnd () {\n  this._maybeClose()\n}\n\nStream.prototype._checkEnded = function _checkEnded (callback) {\n  var state = this._spdyState\n\n  var ended = false\n  if (state.aborted) { ended = true }\n\n  if (!state.writable || this._writableState.finished) { ended = true }\n\n  if (!ended) {\n    return true\n  }\n\n  if (!callback) {\n    return false\n  }\n\n  var err = new Error('Ended stream can\\'t send frames')\n  process.nextTick(function () {\n    callback(err)\n  })\n\n  return false\n}\n\nStream.prototype._maybeClose = function _maybeClose () {\n  var state = this._spdyState\n\n  // .abort() emits `close`\n  if (state.aborted) {\n    return\n  }\n\n  if ((!state.readable || this._readableState.ended) &&\n      this._writableState.finished) {\n    // Clear timeout\n    state.timeout.set(0)\n\n    this.emit('close')\n  }\n}\n\nStream.prototype._handlePushPromise = function _handlePushPromise (frame) {\n  var push = this.connection._createStream({\n    id: frame.promisedId,\n    parent: this,\n    push: true,\n    request: true,\n    method: frame.headers[':method'],\n    path: frame.headers[':path'],\n    host: frame.headers[':authority'],\n    priority: frame.priority,\n    headers: frame.headers,\n    writable: false\n  })\n\n  // GOAWAY\n  if (this.connection._isGoaway(push.id)) {\n    return\n  }\n\n  if (!this.emit('pushPromise', push)) {\n    push.abort()\n  }\n}\n\nStream.prototype._hardCork = function _hardCork () {\n  var state = this._spdyState\n\n  this.cork()\n  state.corked++\n}\n\nStream.prototype._hardUncork = function _hardUncork () {\n  var state = this._spdyState\n\n  this.uncork()\n  state.corked--\n  if (state.corked !== 0) {\n    return\n  }\n\n  // Invoke callbacks\n  var queue = state.corkQueue\n  state.corkQueue = []\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n}\n\nStream.prototype._sendPush = function _sendPush (status, response, callback) {\n  var self = this\n  var state = this._spdyState\n\n  this._hardCork()\n  state.framer.pushFrame({\n    id: this.parent.id,\n    promisedId: this.id,\n    priority: state.priority.toJSON(),\n    path: this.path,\n    host: this.host,\n    method: this.method,\n    status: status,\n    headers: this.headers,\n    response: response\n  }, function (err) {\n    self._hardUncork()\n\n    callback(err)\n  })\n}\n\nStream.prototype._wasSent = function _wasSent () {\n  var state = this._spdyState\n  return state.sent\n}\n\n// Public API\n\nStream.prototype.send = function send (callback) {\n  var state = this._spdyState\n\n  if (state.sent) {\n    var err = new Error('Stream was already sent')\n    process.nextTick(function () {\n      if (callback) {\n        callback(err)\n      }\n    })\n    return\n  }\n\n  state.sent = true\n  state.timeout.reset()\n\n  // GET requests should always be auto-finished\n  if (this.method === 'GET') {\n    this._writableState.ended = true\n    this._writableState.finished = true\n  }\n\n  // TODO(indunty): ideally it should just take a stream object as an input\n  var self = this\n  this._hardCork()\n  state.framer.requestFrame({\n    id: this.id,\n    method: this.method,\n    path: this.path,\n    host: this.host,\n    priority: state.priority.toJSON(),\n    headers: this.headers,\n    fin: this._writableState.finished\n  }, function (err) {\n    self._hardUncork()\n\n    if (!callback) {\n      return\n    }\n\n    callback(err)\n  })\n}\n\nStream.prototype.respond = function respond (status, headers, callback) {\n  var self = this\n  var state = this._spdyState\n  assert(!state.request, 'Can\\'t respond on request')\n\n  state.timeout.reset()\n\n  if (!this._checkEnded(callback)) { return }\n\n  var frame = {\n    id: this.id,\n    status: status,\n    headers: headers\n  }\n  this._hardCork()\n  state.framer.responseFrame(frame, function (err) {\n    self._hardUncork()\n    if (callback) { callback(err) }\n  })\n}\n\nStream.prototype.setWindow = function setWindow (size) {\n  var state = this._spdyState\n\n  state.timeout.reset()\n\n  if (!this._checkEnded()) {\n    return\n  }\n\n  state.debug('id=%d force window max=%d', this.id, size)\n  state.window.recv.setMax(size)\n\n  var delta = state.window.recv.getDelta()\n  if (delta === 0) { return }\n\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  })\n  state.window.recv.update(delta)\n}\n\nStream.prototype.sendHeaders = function sendHeaders (headers, callback) {\n  var self = this\n  var state = this._spdyState\n\n  state.timeout.reset()\n\n  if (!this._checkEnded(callback)) {\n    return\n  }\n\n  // Request wasn't yet send, coalesce headers\n  if (!state.sent) {\n    this.headers = Object.assign({}, this.headers)\n    Object.assign(this.headers, headers)\n    process.nextTick(function () {\n      if (callback) {\n        callback(null)\n      }\n    })\n    return\n  }\n\n  this._hardCork()\n  state.framer.headersFrame({\n    id: this.id,\n    headers: headers\n  }, function (err) {\n    self._hardUncork()\n    if (callback) { callback(err) }\n  })\n}\n\nStream.prototype._destroy = function destroy () {\n  this.abort()\n}\n\nStream.prototype.abort = function abort (code, callback) {\n  var state = this._spdyState\n\n  // .abort(callback)\n  if (typeof code === 'function') {\n    callback = code\n    code = null\n  }\n\n  if (this._readableState.ended && this._writableState.finished) {\n    state.debug('id=%d already closed', this.id)\n    if (callback) {\n      process.nextTick(callback)\n    }\n    return\n  }\n\n  if (state.aborted) {\n    state.debug('id=%d already aborted', this.id)\n    if (callback) { process.nextTick(callback) }\n    return\n  }\n\n  state.aborted = true\n  state.debug('id=%d abort', this.id)\n\n  this.setTimeout(0)\n\n  var abortCode = code || 'CANCEL'\n\n  state.framer.rstFrame({\n    id: this.id,\n    code: abortCode\n  })\n\n  var self = this\n  process.nextTick(function () {\n    if (callback) {\n      callback(null)\n    }\n    self.emit('close', new Error('Aborted, code: ' + abortCode))\n  })\n}\n\nStream.prototype.setPriority = function setPriority (info) {\n  var state = this._spdyState\n\n  state.timeout.reset()\n\n  if (!this._checkEnded()) {\n    return\n  }\n\n  state.debug('id=%d priority change', this.id, info)\n\n  var frame = { id: this.id, priority: info }\n\n  // Change priority on this side\n  this._handlePriority(frame)\n\n  // And on the other too\n  state.framer.priorityFrame(frame)\n}\n\nStream.prototype.pushPromise = function pushPromise (uri, callback) {\n  if (!this._checkEnded(callback)) {\n    return\n  }\n\n  var self = this\n  this._hardCork()\n  var push = this.connection.pushPromise(this, uri, function (err) {\n    self._hardUncork()\n    if (!err) {\n      push._hardUncork()\n    }\n\n    if (callback) {\n      return callback(err, push)\n    }\n\n    if (err) { push.emit('error', err) }\n  })\n  push._hardCork()\n\n  return push\n}\n\nStream.prototype.setMaxChunk = function setMaxChunk (size) {\n  var state = this._spdyState\n  state.maxChunk = size\n}\n\nStream.prototype.setTimeout = function setTimeout (delay, callback) {\n  var state = this._spdyState\n\n  state.timeout.set(delay, callback)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}