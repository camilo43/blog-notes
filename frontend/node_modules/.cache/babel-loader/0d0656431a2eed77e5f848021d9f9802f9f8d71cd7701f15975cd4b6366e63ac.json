{"ast":null,"code":"#! /usr/bin/env node\n'use strict';\n\nconst path = require('path');\nconst fs = require('fs');\nconst url = require('url');\nconst {\n  Readable\n} = require('stream');\nconst buffer = require('buffer');\nconst mime = require('mime');\nconst urlJoin = require('url-join');\nconst showDir = require('./show-dir');\nconst version = require('../../package.json').version;\nconst status = require('./status-handlers');\nconst generateEtag = require('./etag');\nconst optsParser = require('./opts');\nconst htmlEncodingSniffer = require('html-encoding-sniffer');\nlet httpServerCore = null;\nfunction decodePathname(pathname) {\n  const pieces = pathname.replace(/\\\\/g, '/').split('/');\n  const normalized = path.normalize(pieces.map(rawPiece => {\n    const piece = decodeURIComponent(rawPiece);\n    if (process.platform === 'win32' && /\\\\/.test(piece)) {\n      throw new Error('Invalid forward slash character');\n    }\n    return piece;\n  }).join('/'));\n  return process.platform === 'win32' ? normalized.replace(/\\\\/g, '/') : normalized;\n}\nconst nonUrlSafeCharsRgx = /[\\x00-\\x1F\\x20\\x7F-\\uFFFF]+/g;\nfunction ensureUriEncoded(text) {\n  return text;\n  return String(text).replace(nonUrlSafeCharsRgx, encodeURIComponent);\n}\n\n// Check to see if we should try to compress a file with gzip.\nfunction shouldCompressGzip(req) {\n  const headers = req.headers;\n  return headers && headers['accept-encoding'] && headers['accept-encoding'].split(',').some(el => ['*', 'compress', 'gzip', 'deflate'].indexOf(el.trim()) !== -1);\n}\nfunction shouldCompressBrotli(req) {\n  const headers = req.headers;\n  return headers && headers['accept-encoding'] && headers['accept-encoding'].split(',').some(el => ['*', 'br'].indexOf(el.trim()) !== -1);\n}\nfunction hasGzipId12(gzipped, cb) {\n  const stream = fs.createReadStream(gzipped, {\n    start: 0,\n    end: 1\n  });\n  let buffer = Buffer.from('');\n  let hasBeenCalled = false;\n  stream.on('data', chunk => {\n    buffer = Buffer.concat([buffer, chunk], 2);\n  });\n  stream.on('error', err => {\n    if (hasBeenCalled) {\n      throw err;\n    }\n    hasBeenCalled = true;\n    cb(err);\n  });\n  stream.on('close', () => {\n    if (hasBeenCalled) {\n      return;\n    }\n    hasBeenCalled = true;\n    cb(null, buffer[0] === 31 && buffer[1] === 139);\n  });\n}\nmodule.exports = function createMiddleware(_dir, _options) {\n  let dir;\n  let options;\n  if (typeof _dir === 'string') {\n    dir = _dir;\n    options = _options;\n  } else {\n    options = _dir;\n    dir = options.root;\n  }\n  const root = path.join(path.resolve(dir), '/');\n  const opts = optsParser(options);\n  const cache = opts.cache;\n  const autoIndex = opts.autoIndex;\n  const baseDir = opts.baseDir;\n  let defaultExt = opts.defaultExt;\n  const handleError = opts.handleError;\n  const headers = opts.headers;\n  const weakEtags = opts.weakEtags;\n  const handleOptionsMethod = opts.handleOptionsMethod;\n  opts.root = dir;\n  if (defaultExt && /^\\./.test(defaultExt)) {\n    defaultExt = defaultExt.replace(/^\\./, '');\n  }\n\n  // Support hashes and .types files in mimeTypes @since 0.8\n  if (opts.mimeTypes) {\n    try {\n      // You can pass a JSON blob here---useful for CLI use\n      opts.mimeTypes = JSON.parse(opts.mimeTypes);\n    } catch (e) {\n      // swallow parse errors, treat this as a string mimetype input\n    }\n    if (typeof opts.mimeTypes === 'string') {\n      mime.load(opts.mimeTypes);\n    } else if (typeof opts.mimeTypes === 'object') {\n      mime.define(opts.mimeTypes);\n    }\n  }\n  function shouldReturn304(req, serverLastModified, serverEtag) {\n    if (!req || !req.headers) {\n      return false;\n    }\n    const clientModifiedSince = req.headers['if-modified-since'];\n    const clientEtag = req.headers['if-none-match'];\n    let clientModifiedDate;\n    if (!clientModifiedSince && !clientEtag) {\n      // Client did not provide any conditional caching headers\n      return false;\n    }\n    if (clientModifiedSince) {\n      // Catch \"illegal access\" dates that will crash v8\n      try {\n        clientModifiedDate = new Date(Date.parse(clientModifiedSince));\n      } catch (err) {\n        return false;\n      }\n      if (clientModifiedDate.toString() === 'Invalid Date') {\n        return false;\n      }\n      // If the client's copy is older than the server's, don't return 304\n      if (clientModifiedDate < new Date(serverLastModified)) {\n        return false;\n      }\n    }\n    if (clientEtag) {\n      // Do a strong or weak etag comparison based on setting\n      // https://www.ietf.org/rfc/rfc2616.txt Section 13.3.3\n      if (opts.weakCompare && clientEtag !== serverEtag && clientEtag !== `W/${serverEtag}` && `W/${clientEtag}` !== serverEtag) {\n        return false;\n      }\n      if (!opts.weakCompare && (clientEtag !== serverEtag || clientEtag.indexOf('W/') === 0)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return function middleware(req, res, next) {\n    // Figure out the path for the file from the given url\n    const parsed = url.parse(req.url);\n    let pathname = null;\n    let file = null;\n    let gzippedFile = null;\n    let brotliFile = null;\n    try {\n      decodeURIComponent(req.url); // check validity of url\n      pathname = decodePathname(parsed.pathname);\n    } catch (err) {\n      status[400](res, next, {\n        error: err\n      });\n      return;\n    }\n    file = path.normalize(path.join(root, path.relative(path.join('/', baseDir), pathname)));\n    // determine compressed forms if they were to exist\n    gzippedFile = `${file}.gz`;\n    brotliFile = `${file}.br`;\n    Object.keys(headers).forEach(key => {\n      res.setHeader(key, headers[key]);\n    });\n    if (req.method === 'OPTIONS' && handleOptionsMethod) {\n      res.end();\n      return;\n    }\n\n    // TODO: This check is broken, which causes the 403 on the\n    // expected 404.\n    if (file.slice(0, root.length) !== root) {\n      status[403](res, next);\n      return;\n    }\n    if (req.method && req.method !== 'GET' && req.method !== 'HEAD') {\n      status[405](res, next);\n      return;\n    }\n    function serve(stat) {\n      // Do a MIME lookup, fall back to octet-stream and handle gzip\n      // and brotli special case.\n      const defaultType = opts.contentType || 'application/octet-stream';\n      let contentType = mime.lookup(file, defaultType);\n      const range = req.headers && req.headers.range;\n      const lastModified = new Date(stat.mtime).toUTCString();\n      const etag = generateEtag(stat, weakEtags);\n      let cacheControl = cache;\n      let stream = null;\n      if (contentType && isTextFile(contentType)) {\n        if (stat.size < buffer.constants.MAX_LENGTH) {\n          const bytes = fs.readFileSync(file);\n          const sniffedEncoding = htmlEncodingSniffer(bytes, {\n            defaultEncoding: 'UTF-8'\n          });\n          contentType += `; charset=${sniffedEncoding}`;\n          stream = Readable.from(bytes);\n        } else {\n          // Assume text types are utf8\n          contentType += '; charset=UTF-8';\n        }\n      }\n      if (file === gzippedFile) {\n        // is .gz picked up\n        res.setHeader('Content-Encoding', 'gzip');\n        // strip gz ending and lookup mime type\n        contentType = mime.lookup(path.basename(file, '.gz'), defaultType);\n      } else if (file === brotliFile) {\n        // is .br picked up\n        res.setHeader('Content-Encoding', 'br');\n        // strip br ending and lookup mime type\n        contentType = mime.lookup(path.basename(file, '.br'), defaultType);\n      }\n      if (typeof cacheControl === 'function') {\n        cacheControl = cache(pathname);\n      }\n      if (typeof cacheControl === 'number') {\n        cacheControl = `max-age=${cacheControl}`;\n      }\n      if (range) {\n        const total = stat.size;\n        const parts = range.trim().replace(/bytes=/, '').split('-');\n        const partialstart = parts[0];\n        const partialend = parts[1];\n        const start = parseInt(partialstart, 10);\n        const end = Math.min(total - 1, partialend ? parseInt(partialend, 10) : total - 1);\n        const chunksize = end - start + 1;\n        let fstream = null;\n        if (start > end || isNaN(start) || isNaN(end)) {\n          status['416'](res, next);\n          return;\n        }\n        fstream = fs.createReadStream(file, {\n          start,\n          end\n        });\n        fstream.on('error', err => {\n          status['500'](res, next, {\n            error: err\n          });\n        });\n        res.on('close', () => {\n          fstream.destroy();\n        });\n        res.writeHead(206, {\n          'Content-Range': `bytes ${start}-${end}/${total}`,\n          'Accept-Ranges': 'bytes',\n          'Content-Length': chunksize,\n          'Content-Type': contentType,\n          'cache-control': cacheControl,\n          'last-modified': lastModified,\n          etag\n        });\n        fstream.pipe(res);\n        return;\n      }\n\n      // TODO: Helper for this, with default headers.\n      res.setHeader('cache-control', cacheControl);\n      res.setHeader('last-modified', lastModified);\n      res.setHeader('etag', etag);\n\n      // Return a 304 if necessary\n      if (shouldReturn304(req, lastModified, etag)) {\n        status[304](res, next);\n        return;\n      }\n      res.setHeader('content-length', stat.size);\n      res.setHeader('content-type', contentType);\n\n      // set the response statusCode if we have a request statusCode.\n      // This only can happen if we have a 404 with some kind of 404.html\n      // In all other cases where we have a file we serve the 200\n      res.statusCode = req.statusCode || 200;\n      if (req.method === 'HEAD') {\n        res.end();\n        return;\n      }\n\n      // stream may already have been assigned during encoding sniffing.\n      if (stream === null) {\n        stream = fs.createReadStream(file);\n      }\n      stream.pipe(res);\n      stream.on('error', err => {\n        status['500'](res, next, {\n          error: err\n        });\n      });\n      stream.on('close', () => {\n        stream.destroy();\n      });\n    }\n    function statFile() {\n      try {\n        fs.stat(file, (err, stat) => {\n          if (err && (err.code === 'ENOENT' || err.code === 'ENOTDIR')) {\n            if (req.statusCode === 404) {\n              // This means we're already trying ./404.html and can not find it.\n              // So send plain text response with 404 status code\n              status[404](res, next);\n            } else if (!path.extname(parsed.pathname).length && defaultExt) {\n              // If there is no file extension in the path and we have a default\n              // extension try filename and default extension combination before rendering 404.html.\n              middleware({\n                url: `${parsed.pathname}.${defaultExt}${parsed.search ? parsed.search : ''}`,\n                headers: req.headers\n              }, res, next);\n            } else {\n              // Try to serve default ./404.html\n              const rawUrl = handleError ? `/${path.join(baseDir, `404.${defaultExt}`)}` : req.url;\n              const encodedUrl = ensureUriEncoded(rawUrl);\n              middleware({\n                url: encodedUrl,\n                headers: req.headers,\n                statusCode: 404\n              }, res, next);\n            }\n          } else if (err) {\n            status[500](res, next, {\n              error: err\n            });\n          } else if (stat.isDirectory()) {\n            if (!autoIndex && !opts.showDir) {\n              status[404](res, next);\n              return;\n            }\n\n            // 302 to / if necessary\n            if (!pathname.match(/\\/$/)) {\n              res.statusCode = 302;\n              const q = parsed.query ? `?${parsed.query}` : '';\n              res.setHeader('location', ensureUriEncoded(`${parsed.pathname}/${q}`));\n              res.end();\n              return;\n            }\n            if (autoIndex) {\n              middleware({\n                url: urlJoin(encodeURIComponent(pathname), `/index.${defaultExt}`),\n                headers: req.headers\n              }, res, autoIndexError => {\n                if (autoIndexError) {\n                  status[500](res, next, {\n                    error: autoIndexError\n                  });\n                  return;\n                }\n                if (opts.showDir) {\n                  showDir(opts, stat)(req, res);\n                  return;\n                }\n                status[403](res, next);\n              });\n              return;\n            }\n            if (opts.showDir) {\n              showDir(opts, stat)(req, res);\n            }\n          } else {\n            serve(stat);\n          }\n        });\n      } catch (err) {\n        status[500](res, next, {\n          error: err.message\n        });\n      }\n    }\n    function isTextFile(mimeType) {\n      return /^text\\/|^application\\/(javascript|json)/.test(mimeType);\n    }\n\n    // serve gzip file if exists and is valid\n    function tryServeWithGzip() {\n      try {\n        fs.stat(gzippedFile, (err, stat) => {\n          if (!err && stat.isFile()) {\n            hasGzipId12(gzippedFile, (gzipErr, isGzip) => {\n              if (!gzipErr && isGzip) {\n                file = gzippedFile;\n                serve(stat);\n              } else {\n                statFile();\n              }\n            });\n          } else {\n            statFile();\n          }\n        });\n      } catch (err) {\n        status[500](res, next, {\n          error: err.message\n        });\n      }\n    }\n\n    // serve brotli file if exists, otherwise try gzip\n    function tryServeWithBrotli(shouldTryGzip) {\n      try {\n        fs.stat(brotliFile, (err, stat) => {\n          if (!err && stat.isFile()) {\n            file = brotliFile;\n            serve(stat);\n          } else if (shouldTryGzip) {\n            tryServeWithGzip();\n          } else {\n            statFile();\n          }\n        });\n      } catch (err) {\n        status[500](res, next, {\n          error: err.message\n        });\n      }\n    }\n    const shouldTryBrotli = opts.brotli && shouldCompressBrotli(req);\n    const shouldTryGzip = opts.gzip && shouldCompressGzip(req);\n    // always try brotli first, next try gzip, finally serve without compression\n    if (shouldTryBrotli) {\n      tryServeWithBrotli(shouldTryGzip);\n    } else if (shouldTryGzip) {\n      tryServeWithGzip();\n    } else {\n      statFile();\n    }\n  };\n};\nhttpServerCore = module.exports;\nhttpServerCore.version = version;\nhttpServerCore.showDir = showDir;","map":{"version":3,"names":["path","require","fs","url","Readable","buffer","mime","urlJoin","showDir","version","status","generateEtag","optsParser","htmlEncodingSniffer","httpServerCore","decodePathname","pathname","pieces","replace","split","normalized","normalize","map","rawPiece","piece","decodeURIComponent","process","platform","test","Error","join","nonUrlSafeCharsRgx","ensureUriEncoded","text","String","encodeURIComponent","shouldCompressGzip","req","headers","some","el","indexOf","trim","shouldCompressBrotli","hasGzipId12","gzipped","cb","stream","createReadStream","start","end","Buffer","from","hasBeenCalled","on","chunk","concat","err","module","exports","createMiddleware","_dir","_options","dir","options","root","resolve","opts","cache","autoIndex","baseDir","defaultExt","handleError","weakEtags","handleOptionsMethod","mimeTypes","JSON","parse","e","load","define","shouldReturn304","serverLastModified","serverEtag","clientModifiedSince","clientEtag","clientModifiedDate","Date","toString","weakCompare","middleware","res","next","parsed","file","gzippedFile","brotliFile","error","relative","Object","keys","forEach","key","setHeader","method","slice","length","serve","stat","defaultType","contentType","lookup","range","lastModified","mtime","toUTCString","etag","cacheControl","isTextFile","size","constants","MAX_LENGTH","bytes","readFileSync","sniffedEncoding","defaultEncoding","basename","total","parts","partialstart","partialend","parseInt","Math","min","chunksize","fstream","isNaN","destroy","writeHead","pipe","statusCode","statFile","code","extname","search","rawUrl","encodedUrl","isDirectory","match","q","query","autoIndexError","message","mimeType","tryServeWithGzip","isFile","gzipErr","isGzip","tryServeWithBrotli","shouldTryGzip","shouldTryBrotli","brotli","gzip"],"sources":["/Users/juancvegao/Documents/PROGRAMMING/REACT/ejerciciosUniversidad/notes_github/frontend/node_modules/http-server/lib/core/index.js"],"sourcesContent":["#! /usr/bin/env node\n\n'use strict';\n\nconst path = require('path');\nconst fs = require('fs');\nconst url = require('url');\nconst { Readable } = require('stream');\nconst buffer = require('buffer');\nconst mime = require('mime');\nconst urlJoin = require('url-join');\nconst showDir = require('./show-dir');\nconst version = require('../../package.json').version;\nconst status = require('./status-handlers');\nconst generateEtag = require('./etag');\nconst optsParser = require('./opts');\nconst htmlEncodingSniffer = require('html-encoding-sniffer');\n\nlet httpServerCore = null;\n\nfunction decodePathname(pathname) {\n  const pieces = pathname.replace(/\\\\/g, '/').split('/');\n\n  const normalized = path.normalize(pieces.map((rawPiece) => {\n    const piece = decodeURIComponent(rawPiece);\n\n    if (process.platform === 'win32' && /\\\\/.test(piece)) {\n      throw new Error('Invalid forward slash character');\n    }\n\n    return piece;\n  }).join('/'));\n  return process.platform === 'win32'\n    ? normalized.replace(/\\\\/g, '/') : normalized;\n}\n\nconst nonUrlSafeCharsRgx = /[\\x00-\\x1F\\x20\\x7F-\\uFFFF]+/g;\nfunction ensureUriEncoded(text) {\n  return text\n  return String(text).replace(nonUrlSafeCharsRgx, encodeURIComponent);\n}\n\n// Check to see if we should try to compress a file with gzip.\nfunction shouldCompressGzip(req) {\n  const headers = req.headers;\n\n  return headers && headers['accept-encoding'] &&\n    headers['accept-encoding']\n    .split(',')\n    .some(el => ['*', 'compress', 'gzip', 'deflate'].indexOf(el.trim()) !== -1)\n  ;\n}\n\nfunction shouldCompressBrotli(req) {\n  const headers = req.headers;\n\n  return headers && headers['accept-encoding'] &&\n    headers['accept-encoding']\n    .split(',')\n    .some(el => ['*', 'br'].indexOf(el.trim()) !== -1)\n  ;\n}\n\nfunction hasGzipId12(gzipped, cb) {\n  const stream = fs.createReadStream(gzipped, { start: 0, end: 1 });\n  let buffer = Buffer.from('');\n  let hasBeenCalled = false;\n\n  stream.on('data', (chunk) => {\n    buffer = Buffer.concat([buffer, chunk], 2);\n  });\n\n  stream.on('error', (err) => {\n    if (hasBeenCalled) {\n      throw err;\n    }\n\n    hasBeenCalled = true;\n    cb(err);\n  });\n\n  stream.on('close', () => {\n    if (hasBeenCalled) {\n      return;\n    }\n\n    hasBeenCalled = true;\n    cb(null, buffer[0] === 31 && buffer[1] === 139);\n  });\n}\n\n\nmodule.exports = function createMiddleware(_dir, _options) {\n  let dir;\n  let options;\n  if (typeof _dir === 'string') {\n    dir = _dir;\n    options = _options;\n  } else {\n    options = _dir;\n    dir = options.root;\n  }\n\n  const root = path.join(path.resolve(dir), '/');\n  const opts = optsParser(options);\n  const cache = opts.cache;\n  const autoIndex = opts.autoIndex;\n  const baseDir = opts.baseDir;\n  let defaultExt = opts.defaultExt;\n  const handleError = opts.handleError;\n  const headers = opts.headers;\n  const weakEtags = opts.weakEtags;\n  const handleOptionsMethod = opts.handleOptionsMethod;\n\n  opts.root = dir;\n  if (defaultExt && /^\\./.test(defaultExt)) {\n    defaultExt = defaultExt.replace(/^\\./, '');\n  }\n\n  // Support hashes and .types files in mimeTypes @since 0.8\n  if (opts.mimeTypes) {\n    try {\n      // You can pass a JSON blob here---useful for CLI use\n      opts.mimeTypes = JSON.parse(opts.mimeTypes);\n    } catch (e) {\n      // swallow parse errors, treat this as a string mimetype input\n    }\n    if (typeof opts.mimeTypes === 'string') {\n      mime.load(opts.mimeTypes);\n    } else if (typeof opts.mimeTypes === 'object') {\n      mime.define(opts.mimeTypes);\n    }\n  }\n\n  function shouldReturn304(req, serverLastModified, serverEtag) {\n    if (!req || !req.headers) {\n      return false;\n    }\n\n    const clientModifiedSince = req.headers['if-modified-since'];\n    const clientEtag = req.headers['if-none-match'];\n    let clientModifiedDate;\n\n    if (!clientModifiedSince && !clientEtag) {\n      // Client did not provide any conditional caching headers\n      return false;\n    }\n\n    if (clientModifiedSince) {\n      // Catch \"illegal access\" dates that will crash v8\n      try {\n        clientModifiedDate = new Date(Date.parse(clientModifiedSince));\n      } catch (err) {\n        return false;\n      }\n\n      if (clientModifiedDate.toString() === 'Invalid Date') {\n        return false;\n      }\n      // If the client's copy is older than the server's, don't return 304\n      if (clientModifiedDate < new Date(serverLastModified)) {\n        return false;\n      }\n    }\n\n    if (clientEtag) {\n      // Do a strong or weak etag comparison based on setting\n      // https://www.ietf.org/rfc/rfc2616.txt Section 13.3.3\n      if (opts.weakCompare && clientEtag !== serverEtag\n          && clientEtag !== `W/${serverEtag}` && `W/${clientEtag}` !== serverEtag) {\n        return false;\n      }\n      if (!opts.weakCompare && (clientEtag !== serverEtag || clientEtag.indexOf('W/') === 0)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return function middleware(req, res, next) {\n    // Figure out the path for the file from the given url\n    const parsed = url.parse(req.url);\n    let pathname = null;\n    let file = null;\n    let gzippedFile = null;\n    let brotliFile = null;\n\n    try {\n      decodeURIComponent(req.url); // check validity of url\n      pathname = decodePathname(parsed.pathname);\n    } catch (err) {\n      status[400](res, next, { error: err });\n      return;\n    }\n\n    file = path.normalize(\n      path.join(\n        root,\n        path.relative(path.join('/', baseDir), pathname)\n      )\n    );\n    // determine compressed forms if they were to exist\n    gzippedFile = `${file}.gz`;\n    brotliFile = `${file}.br`;\n\n    Object.keys(headers).forEach((key) => {\n      res.setHeader(key, headers[key]);\n    });\n\n    if (req.method === 'OPTIONS' && handleOptionsMethod) {\n      res.end();\n      return;\n    }\n\n    // TODO: This check is broken, which causes the 403 on the\n    // expected 404.\n    if (file.slice(0, root.length) !== root) {\n      status[403](res, next);\n      return;\n    }\n\n    if (req.method && (req.method !== 'GET' && req.method !== 'HEAD')) {\n      status[405](res, next);\n      return;\n    }\n\n\n    function serve(stat) {\n      // Do a MIME lookup, fall back to octet-stream and handle gzip\n      // and brotli special case.\n      const defaultType = opts.contentType || 'application/octet-stream';\n      let contentType = mime.lookup(file, defaultType);\n      const range = (req.headers && req.headers.range);\n      const lastModified = (new Date(stat.mtime)).toUTCString();\n      const etag = generateEtag(stat, weakEtags);\n      let cacheControl = cache;\n      let stream = null;\n      if (contentType && isTextFile(contentType)) {\n        if (stat.size < buffer.constants.MAX_LENGTH) {\n          const bytes = fs.readFileSync(file);\n          const sniffedEncoding = htmlEncodingSniffer(bytes, {\n            defaultEncoding: 'UTF-8'\n          });\n          contentType += `; charset=${sniffedEncoding}`;\n          stream = Readable.from(bytes)\n        } else {\n          // Assume text types are utf8\n          contentType += '; charset=UTF-8';\n        }\n      }\n\n      if (file === gzippedFile) { // is .gz picked up\n        res.setHeader('Content-Encoding', 'gzip');\n        // strip gz ending and lookup mime type\n        contentType = mime.lookup(path.basename(file, '.gz'), defaultType);\n      } else if (file === brotliFile) { // is .br picked up\n        res.setHeader('Content-Encoding', 'br');\n        // strip br ending and lookup mime type\n        contentType = mime.lookup(path.basename(file, '.br'), defaultType);\n      }\n\n      if (typeof cacheControl === 'function') {\n        cacheControl = cache(pathname);\n      }\n      if (typeof cacheControl === 'number') {\n        cacheControl = `max-age=${cacheControl}`;\n      }\n\n      if (range) {\n        const total = stat.size;\n        const parts = range.trim().replace(/bytes=/, '').split('-');\n        const partialstart = parts[0];\n        const partialend = parts[1];\n        const start = parseInt(partialstart, 10);\n        const end = Math.min(\n          total - 1,\n          partialend ? parseInt(partialend, 10) : total - 1\n        );\n        const chunksize = (end - start) + 1;\n        let fstream = null;\n\n        if (start > end || isNaN(start) || isNaN(end)) {\n          status['416'](res, next);\n          return;\n        }\n\n        fstream = fs.createReadStream(file, { start, end });\n        fstream.on('error', (err) => {\n          status['500'](res, next, { error: err });\n        });\n        res.on('close', () => {\n          fstream.destroy();\n        });\n        res.writeHead(206, {\n          'Content-Range': `bytes ${start}-${end}/${total}`,\n          'Accept-Ranges': 'bytes',\n          'Content-Length': chunksize,\n          'Content-Type': contentType,\n          'cache-control': cacheControl,\n          'last-modified': lastModified,\n          etag,\n        });\n        fstream.pipe(res);\n        return;\n      }\n\n      // TODO: Helper for this, with default headers.\n      res.setHeader('cache-control', cacheControl);\n      res.setHeader('last-modified', lastModified);\n      res.setHeader('etag', etag);\n\n      // Return a 304 if necessary\n      if (shouldReturn304(req, lastModified, etag)) {\n        status[304](res, next);\n        return;\n      }\n\n      res.setHeader('content-length', stat.size);\n      res.setHeader('content-type', contentType);\n\n      // set the response statusCode if we have a request statusCode.\n      // This only can happen if we have a 404 with some kind of 404.html\n      // In all other cases where we have a file we serve the 200\n      res.statusCode = req.statusCode || 200;\n\n      if (req.method === 'HEAD') {\n        res.end();\n        return;\n      }\n\n      // stream may already have been assigned during encoding sniffing.\n      if (stream === null) {\n        stream = fs.createReadStream(file);\n      }\n\n      stream.pipe(res);\n      stream.on('error', (err) => {\n        status['500'](res, next, { error: err });\n      });\n      stream.on('close', () => {\n        stream.destroy();\n      })\n    }\n\n\n    function statFile() {\n      try {\n        fs.stat(file, (err, stat) => {\n          if (err && (err.code === 'ENOENT' || err.code === 'ENOTDIR')) {\n            if (req.statusCode === 404) {\n              // This means we're already trying ./404.html and can not find it.\n              // So send plain text response with 404 status code\n              status[404](res, next);\n            } else if (!path.extname(parsed.pathname).length && defaultExt) {\n              // If there is no file extension in the path and we have a default\n              // extension try filename and default extension combination before rendering 404.html.\n              middleware({\n                url: `${parsed.pathname}.${defaultExt}${(parsed.search) ? parsed.search : ''}`,\n                headers: req.headers,\n              }, res, next);\n            } else {\n              // Try to serve default ./404.html\n              const rawUrl = (handleError ? `/${path.join(baseDir, `404.${defaultExt}`)}` : req.url);\n              const encodedUrl = ensureUriEncoded(rawUrl);\n              middleware({\n                url: encodedUrl,\n                headers: req.headers,\n                statusCode: 404,\n              }, res, next);\n            }\n          } else if (err) {\n            status[500](res, next, { error: err });\n          } else if (stat.isDirectory()) {\n            if (!autoIndex && !opts.showDir) {\n              status[404](res, next);\n              return;\n            }\n\n\n            // 302 to / if necessary\n            if (!pathname.match(/\\/$/)) {\n              res.statusCode = 302;\n              const q = parsed.query ? `?${parsed.query}` : '';\n              res.setHeader(\n                'location',\n                ensureUriEncoded(`${parsed.pathname}/${q}`)\n              );\n              res.end();\n              return;\n            }\n\n            if (autoIndex) {\n              middleware({\n                url: urlJoin(\n                  encodeURIComponent(pathname),\n                  `/index.${defaultExt}`\n                ),\n                headers: req.headers,\n              }, res, (autoIndexError) => {\n                if (autoIndexError) {\n                  status[500](res, next, { error: autoIndexError });\n                  return;\n                }\n                if (opts.showDir) {\n                  showDir(opts, stat)(req, res);\n                  return;\n                }\n\n                status[403](res, next);\n              });\n              return;\n            }\n\n            if (opts.showDir) {\n              showDir(opts, stat)(req, res);\n            }\n          } else {\n            serve(stat);\n          }\n        });\n      } catch (err) {\n        status[500](res, next, { error: err.message });\n      }\n    }\n\n    function isTextFile(mimeType) {\n      return (/^text\\/|^application\\/(javascript|json)/).test(mimeType);\n    }\n\n    // serve gzip file if exists and is valid\n    function tryServeWithGzip() {\n      try {\n        fs.stat(gzippedFile, (err, stat) => {\n          if (!err && stat.isFile()) {\n            hasGzipId12(gzippedFile, (gzipErr, isGzip) => {\n              if (!gzipErr && isGzip) {\n                file = gzippedFile;\n                serve(stat);\n              } else {\n                statFile();\n              }\n            });\n          } else {\n            statFile();\n          }\n        });\n      } catch (err) {\n        status[500](res, next, { error: err.message });\n      }\n    }\n\n    // serve brotli file if exists, otherwise try gzip\n    function tryServeWithBrotli(shouldTryGzip) {\n      try {\n        fs.stat(brotliFile, (err, stat) => {\n          if (!err && stat.isFile()) {\n            file = brotliFile;\n            serve(stat);\n          } else if (shouldTryGzip) {\n            tryServeWithGzip();\n          } else {\n            statFile();\n          }\n        });\n      } catch (err) {\n        status[500](res, next, { error: err.message });\n      }\n    }\n\n    const shouldTryBrotli = opts.brotli && shouldCompressBrotli(req);\n    const shouldTryGzip = opts.gzip && shouldCompressGzip(req);\n    // always try brotli first, next try gzip, finally serve without compression\n    if (shouldTryBrotli) {\n      tryServeWithBrotli(shouldTryGzip);\n    } else if (shouldTryGzip) {\n      tryServeWithGzip();\n    } else {\n      statFile();\n    }\n  };\n};\n\n\nhttpServerCore = module.exports;\nhttpServerCore.version = version;\nhttpServerCore.showDir = showDir;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}