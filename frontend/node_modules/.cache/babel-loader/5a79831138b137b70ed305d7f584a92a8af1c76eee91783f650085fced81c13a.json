{"ast":null,"code":"'use strict';\n\nvar transport = require('../../../spdy-transport');\nvar utils = transport.utils;\nvar assert = require('assert');\nvar util = require('util');\nvar debug = require('debug')('spdy:scheduler');\nvar Readable = require('readable-stream').Readable;\n\n/*\n * We create following structure in `pending`:\n * [ [ id = 0 ], [ id = 1 ], [ id = 2 ], [ id = 0 ] ]\n *     chunks      chunks      chunks      chunks\n *     chunks                  chunks\n *     chunks\n *\n * Then on the `.tick()` pass we pick one chunks from each item and remove the\n * item if it is empty:\n *\n * [ [ id = 0 ], [ id = 2 ] ]\n *     chunks      chunks\n *     chunks\n *\n * Writing out: chunks for 0, chunks for 1, chunks for 2, chunks for 0\n *\n * This way data is interleaved between the different streams.\n */\n\nfunction Scheduler(options) {\n  Readable.call(this);\n\n  // Pretty big window by default\n  this.window = 0.25;\n  if (options && options.window) {\n    this.window = options.window;\n  }\n  this.sync = [];\n  this.list = [];\n  this.count = 0;\n  this.pendingTick = false;\n}\nutil.inherits(Scheduler, Readable);\nmodule.exports = Scheduler;\n\n// Just for testing, really\nScheduler.create = function create(options) {\n  return new Scheduler(options);\n};\nfunction insertCompare(a, b) {\n  return a.priority === b.priority ? a.stream - b.stream : b.priority - a.priority;\n}\nScheduler.prototype.schedule = function schedule(data) {\n  var priority = data.priority;\n  var stream = data.stream;\n  var chunks = data.chunks;\n\n  // Synchronous frames should not be interleaved\n  if (priority === false) {\n    debug('queue sync', chunks);\n    this.sync.push(data);\n    this.count += chunks.length;\n    this._read();\n    return;\n  }\n  debug('queue async priority=%d stream=%d', priority, stream, chunks);\n  var item = new SchedulerItem(stream, priority);\n  var index = utils.binaryLookup(this.list, item, insertCompare);\n\n  // Push new item\n  if (index >= this.list.length || insertCompare(this.list[index], item) !== 0) {\n    this.list.splice(index, 0, item);\n  } else {\n    // Coalesce\n    item = this.list[index];\n  }\n  item.push(data);\n  this.count += chunks.length;\n  this._read();\n};\nScheduler.prototype._read = function _read() {\n  if (this.count === 0) {\n    return;\n  }\n  if (this.pendingTick) {\n    return;\n  }\n  this.pendingTick = true;\n  var self = this;\n  process.nextTick(function () {\n    self.pendingTick = false;\n    self.tick();\n  });\n};\nScheduler.prototype.tick = function tick() {\n  // No luck for async frames\n  if (!this.tickSync()) {\n    return false;\n  }\n  return this.tickAsync();\n};\nScheduler.prototype.tickSync = function tickSync() {\n  // Empty sync queue first\n  var sync = this.sync;\n  var res = true;\n  this.sync = [];\n  for (var i = 0; i < sync.length; i++) {\n    var item = sync[i];\n    debug('tick sync pending=%d', this.count, item.chunks);\n    for (var j = 0; j < item.chunks.length; j++) {\n      this.count--;\n      // TODO: handle stream backoff properly\n      try {\n        res = this.push(item.chunks[j]);\n      } catch (err) {\n        this.emit('error', err);\n        return false;\n      }\n    }\n    debug('after tick sync pending=%d', this.count);\n\n    // TODO(indutny): figure out the way to invoke callback on actual write\n    if (item.callback) {\n      item.callback(null);\n    }\n  }\n  return res;\n};\nScheduler.prototype.tickAsync = function tickAsync() {\n  var res = true;\n  var list = this.list;\n  if (list.length === 0) {\n    return res;\n  }\n  var startPriority = list[0].priority;\n  for (var index = 0; list.length > 0; index++) {\n    // Loop index\n    index %= list.length;\n    if (startPriority - list[index].priority > this.window) {\n      index = 0;\n    }\n    debug('tick async index=%d start=%d', index, startPriority);\n    var current = list[index];\n    var item = current.shift();\n    if (current.isEmpty()) {\n      list.splice(index, 1);\n      if (index === 0 && list.length > 0) {\n        startPriority = list[0].priority;\n      }\n      index--;\n    }\n    debug('tick async pending=%d', this.count, item.chunks);\n    for (var i = 0; i < item.chunks.length; i++) {\n      this.count--;\n      // TODO: handle stream backoff properly\n      try {\n        res = this.push(item.chunks[i]);\n      } catch (err) {\n        this.emit('error', err);\n        return false;\n      }\n    }\n    debug('after tick pending=%d', this.count);\n\n    // TODO(indutny): figure out the way to invoke callback on actual write\n    if (item.callback) {\n      item.callback(null);\n    }\n    if (!res) {\n      break;\n    }\n  }\n  return res;\n};\nScheduler.prototype.dump = function dump() {\n  this.tickSync();\n\n  // Write everything out\n  while (!this.tickAsync()) {\n    // Intentional no-op\n  }\n  assert.strictEqual(this.count, 0);\n};\nfunction SchedulerItem(stream, priority) {\n  this.stream = stream;\n  this.priority = priority;\n  this.queue = [];\n}\nSchedulerItem.prototype.push = function push(chunks) {\n  this.queue.push(chunks);\n};\nSchedulerItem.prototype.shift = function shift() {\n  return this.queue.shift();\n};\nSchedulerItem.prototype.isEmpty = function isEmpty() {\n  return this.queue.length === 0;\n};","map":{"version":3,"names":["transport","require","utils","assert","util","debug","Readable","Scheduler","options","call","window","sync","list","count","pendingTick","inherits","module","exports","create","insertCompare","a","b","priority","stream","prototype","schedule","data","chunks","push","length","_read","item","SchedulerItem","index","binaryLookup","splice","self","process","nextTick","tick","tickSync","tickAsync","res","i","j","err","emit","callback","startPriority","current","shift","isEmpty","dump","strictEqual","queue"],"sources":["/Users/juancvegao/Documents/PROGRAMMING/REACT/ejerciciosUniversidad/notes_github/frontend/node_modules/spdy-transport/lib/spdy-transport/protocol/base/scheduler.js"],"sourcesContent":["'use strict'\n\nvar transport = require('../../../spdy-transport')\nvar utils = transport.utils\n\nvar assert = require('assert')\nvar util = require('util')\nvar debug = require('debug')('spdy:scheduler')\nvar Readable = require('readable-stream').Readable\n\n/*\n * We create following structure in `pending`:\n * [ [ id = 0 ], [ id = 1 ], [ id = 2 ], [ id = 0 ] ]\n *     chunks      chunks      chunks      chunks\n *     chunks                  chunks\n *     chunks\n *\n * Then on the `.tick()` pass we pick one chunks from each item and remove the\n * item if it is empty:\n *\n * [ [ id = 0 ], [ id = 2 ] ]\n *     chunks      chunks\n *     chunks\n *\n * Writing out: chunks for 0, chunks for 1, chunks for 2, chunks for 0\n *\n * This way data is interleaved between the different streams.\n */\n\nfunction Scheduler (options) {\n  Readable.call(this)\n\n  // Pretty big window by default\n  this.window = 0.25\n\n  if (options && options.window) { this.window = options.window }\n\n  this.sync = []\n  this.list = []\n  this.count = 0\n  this.pendingTick = false\n}\nutil.inherits(Scheduler, Readable)\nmodule.exports = Scheduler\n\n// Just for testing, really\nScheduler.create = function create (options) {\n  return new Scheduler(options)\n}\n\nfunction insertCompare (a, b) {\n  return a.priority === b.priority\n    ? a.stream - b.stream\n    : b.priority - a.priority\n}\n\nScheduler.prototype.schedule = function schedule (data) {\n  var priority = data.priority\n  var stream = data.stream\n  var chunks = data.chunks\n\n  // Synchronous frames should not be interleaved\n  if (priority === false) {\n    debug('queue sync', chunks)\n    this.sync.push(data)\n    this.count += chunks.length\n\n    this._read()\n    return\n  }\n\n  debug('queue async priority=%d stream=%d', priority, stream, chunks)\n  var item = new SchedulerItem(stream, priority)\n  var index = utils.binaryLookup(this.list, item, insertCompare)\n\n  // Push new item\n  if (index >= this.list.length || insertCompare(this.list[index], item) !== 0) {\n    this.list.splice(index, 0, item)\n  } else { // Coalesce\n    item = this.list[index]\n  }\n\n  item.push(data)\n\n  this.count += chunks.length\n\n  this._read()\n}\n\nScheduler.prototype._read = function _read () {\n  if (this.count === 0) {\n    return\n  }\n\n  if (this.pendingTick) {\n    return\n  }\n  this.pendingTick = true\n\n  var self = this\n  process.nextTick(function () {\n    self.pendingTick = false\n    self.tick()\n  })\n}\n\nScheduler.prototype.tick = function tick () {\n  // No luck for async frames\n  if (!this.tickSync()) { return false }\n\n  return this.tickAsync()\n}\n\nScheduler.prototype.tickSync = function tickSync () {\n  // Empty sync queue first\n  var sync = this.sync\n  var res = true\n  this.sync = []\n  for (var i = 0; i < sync.length; i++) {\n    var item = sync[i]\n    debug('tick sync pending=%d', this.count, item.chunks)\n    for (var j = 0; j < item.chunks.length; j++) {\n      this.count--\n      // TODO: handle stream backoff properly\n      try {\n        res = this.push(item.chunks[j])\n      } catch (err) {\n        this.emit('error', err)\n        return false\n      }\n    }\n    debug('after tick sync pending=%d', this.count)\n\n    // TODO(indutny): figure out the way to invoke callback on actual write\n    if (item.callback) {\n      item.callback(null)\n    }\n  }\n  return res\n}\n\nScheduler.prototype.tickAsync = function tickAsync () {\n  var res = true\n  var list = this.list\n  if (list.length === 0) {\n    return res\n  }\n\n  var startPriority = list[0].priority\n  for (var index = 0; list.length > 0; index++) {\n    // Loop index\n    index %= list.length\n    if (startPriority - list[index].priority > this.window) { index = 0 }\n    debug('tick async index=%d start=%d', index, startPriority)\n\n    var current = list[index]\n    var item = current.shift()\n\n    if (current.isEmpty()) {\n      list.splice(index, 1)\n      if (index === 0 && list.length > 0) {\n        startPriority = list[0].priority\n      }\n      index--\n    }\n\n    debug('tick async pending=%d', this.count, item.chunks)\n    for (var i = 0; i < item.chunks.length; i++) {\n      this.count--\n      // TODO: handle stream backoff properly\n      try {\n        res = this.push(item.chunks[i])\n      } catch (err) {\n        this.emit('error', err)\n        return false\n      }\n    }\n    debug('after tick pending=%d', this.count)\n\n    // TODO(indutny): figure out the way to invoke callback on actual write\n    if (item.callback) {\n      item.callback(null)\n    }\n    if (!res) { break }\n  }\n\n  return res\n}\n\nScheduler.prototype.dump = function dump () {\n  this.tickSync()\n\n  // Write everything out\n  while (!this.tickAsync()) {\n    // Intentional no-op\n  }\n  assert.strictEqual(this.count, 0)\n}\n\nfunction SchedulerItem (stream, priority) {\n  this.stream = stream\n  this.priority = priority\n  this.queue = []\n}\n\nSchedulerItem.prototype.push = function push (chunks) {\n  this.queue.push(chunks)\n}\n\nSchedulerItem.prototype.shift = function shift () {\n  return this.queue.shift()\n}\n\nSchedulerItem.prototype.isEmpty = function isEmpty () {\n  return this.queue.length === 0\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}