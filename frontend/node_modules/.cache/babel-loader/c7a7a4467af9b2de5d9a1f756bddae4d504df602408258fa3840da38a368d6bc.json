{"ast":null,"code":"var hpack = require('../hpack');\nvar utils = hpack.utils;\nvar huffman = hpack.huffman.decode;\nvar assert = utils.assert;\nvar OffsetBuffer = require('obuf');\nfunction Decoder() {\n  this.buffer = new OffsetBuffer();\n  this.bitOffset = 0;\n\n  // Used internally in decodeStr\n  this._huffmanNode = null;\n}\nmodule.exports = Decoder;\nDecoder.create = function create() {\n  return new Decoder();\n};\nDecoder.prototype.isEmpty = function isEmpty() {\n  return this.buffer.isEmpty();\n};\nDecoder.prototype.push = function push(chunk) {\n  this.buffer.push(chunk);\n};\nDecoder.prototype.decodeBit = function decodeBit() {\n  // Need at least one octet\n  assert(this.buffer.has(1), 'Buffer too small for an int');\n  var octet;\n  var offset = this.bitOffset;\n  if (++this.bitOffset === 8) {\n    octet = this.buffer.readUInt8();\n    this.bitOffset = 0;\n  } else {\n    octet = this.buffer.peekUInt8();\n  }\n  return octet >>> 7 - offset & 1;\n};\n\n// Just for testing\nDecoder.prototype.skipBits = function skipBits(n) {\n  this.bitOffset += n;\n  this.buffer.skip(this.bitOffset >> 3);\n  this.bitOffset &= 0x7;\n};\nDecoder.prototype.decodeInt = function decodeInt() {\n  // Need at least one octet\n  assert(this.buffer.has(1), 'Buffer too small for an int');\n  var prefix = 8 - this.bitOffset;\n\n  // We are going to end up octet-aligned\n  this.bitOffset = 0;\n  var max = (1 << prefix) - 1;\n  var octet = this.buffer.readUInt8() & max;\n\n  // Fast case - int fits into the prefix\n  if (octet !== max) return octet;\n\n  // TODO(indutny): what about > 32bit numbers?\n  var res = 0;\n  var isLast = false;\n  var len = 0;\n  do {\n    octet = this.buffer.readUInt8();\n    isLast = (octet & 0x80) === 0;\n    res <<= 7;\n    res |= octet & 0x7f;\n    len++;\n  } while (!isLast);\n  assert(isLast, 'Incomplete data for multi-octet integer');\n  assert(len <= 4, 'Integer does not fit into 32 bits');\n\n  // Reverse bits\n  res = res >>> 21 | (res >> 14 & 0x7f) << 7 | (res >> 7 & 0x7f) << 14 | (res & 0x7f) << 21;\n  res >>= (4 - len) * 7;\n\n  // Append prefix max\n  res += max;\n  return res;\n};\nDecoder.prototype.decodeHuffmanWord = function decodeHuffmanWord(input, inputBits, out) {\n  var root = huffman;\n  var node = this._huffmanNode;\n  var word = input;\n  var bits = inputBits;\n  for (; bits > 0; word &= (1 << bits) - 1) {\n    // Nudge the word bit length to match it\n    for (var i = Math.max(0, bits - 8); i < bits; i++) {\n      var subnode = node[word >>> i];\n      if (typeof subnode !== 'number') {\n        node = subnode;\n        bits = i;\n        break;\n      }\n      if (subnode === 0) continue;\n\n      // Word bit length should match\n      if (subnode >>> 9 !== bits - i) {\n        subnode = 0;\n        continue;\n      }\n      var octet = subnode & 0x1ff;\n      assert(octet !== 256, 'EOS in encoding');\n      out.push(octet);\n      node = root;\n      bits = i;\n      break;\n    }\n    if (subnode === 0) break;\n  }\n  this._huffmanNode = node;\n  return bits;\n};\nDecoder.prototype.decodeStr = function decodeStr() {\n  var isHuffman = this.decodeBit();\n  var len = this.decodeInt();\n  assert(this.buffer.has(len), 'Not enough octets for string');\n  if (!isHuffman) return this.buffer.take(len);\n  this._huffmanNode = huffman;\n  var out = [];\n  var word = 0;\n  var bits = 0;\n  var lastKey = 0;\n  for (var i = 0; i < len; i++) {\n    word <<= 8;\n    word |= this.buffer.readUInt8();\n    bits += 8;\n    bits = this.decodeHuffmanWord(word, bits, out);\n    lastKey = word >> bits;\n    word &= (1 << bits) - 1;\n  }\n  assert(this._huffmanNode === huffman, '8-bit EOS');\n  assert(word + 1 === 1 << bits, 'Final sequence is not EOS');\n  this._huffmanNode = null;\n  return out;\n};","map":{"version":3,"names":["hpack","require","utils","huffman","decode","assert","OffsetBuffer","Decoder","buffer","bitOffset","_huffmanNode","module","exports","create","prototype","isEmpty","push","chunk","decodeBit","has","octet","offset","readUInt8","peekUInt8","skipBits","n","skip","decodeInt","prefix","max","res","isLast","len","decodeHuffmanWord","input","inputBits","out","root","node","word","bits","i","Math","subnode","decodeStr","isHuffman","take","lastKey"],"sources":["/Users/juancvegao/Documents/PROGRAMMING/REACT/ejerciciosUniversidad/notes_github/frontend/node_modules/hpack.js/lib/hpack/decoder.js"],"sourcesContent":["var hpack = require('../hpack');\nvar utils = hpack.utils;\nvar huffman = hpack.huffman.decode;\nvar assert = utils.assert;\n\nvar OffsetBuffer = require('obuf');\n\nfunction Decoder() {\n  this.buffer = new OffsetBuffer();\n  this.bitOffset = 0;\n\n  // Used internally in decodeStr\n  this._huffmanNode = null;\n}\nmodule.exports = Decoder;\n\nDecoder.create = function create() {\n  return new Decoder();\n};\n\nDecoder.prototype.isEmpty = function isEmpty() {\n  return this.buffer.isEmpty();\n};\n\nDecoder.prototype.push = function push(chunk) {\n  this.buffer.push(chunk);\n};\n\nDecoder.prototype.decodeBit = function decodeBit() {\n  // Need at least one octet\n  assert(this.buffer.has(1), 'Buffer too small for an int');\n\n  var octet;\n  var offset = this.bitOffset;\n\n  if (++this.bitOffset === 8) {\n    octet = this.buffer.readUInt8();\n    this.bitOffset = 0;\n  } else {\n    octet = this.buffer.peekUInt8();\n  }\n  return (octet >>> (7 - offset)) & 1;\n};\n\n// Just for testing\nDecoder.prototype.skipBits = function skipBits(n) {\n  this.bitOffset += n;\n  this.buffer.skip(this.bitOffset >> 3);\n  this.bitOffset &= 0x7;\n};\n\nDecoder.prototype.decodeInt = function decodeInt() {\n  // Need at least one octet\n  assert(this.buffer.has(1), 'Buffer too small for an int');\n\n  var prefix = 8 - this.bitOffset;\n\n  // We are going to end up octet-aligned\n  this.bitOffset = 0;\n\n  var max = (1 << prefix) - 1;\n  var octet = this.buffer.readUInt8() & max;\n\n  // Fast case - int fits into the prefix\n  if (octet !== max)\n    return octet;\n\n  // TODO(indutny): what about > 32bit numbers?\n  var res = 0;\n  var isLast = false;\n  var len = 0;\n  do {\n    octet = this.buffer.readUInt8();\n    isLast = (octet & 0x80) === 0;\n\n    res <<= 7;\n    res |= octet & 0x7f;\n    len++;\n  } while (!isLast);\n  assert(isLast, 'Incomplete data for multi-octet integer');\n  assert(len <= 4, 'Integer does not fit into 32 bits');\n\n  // Reverse bits\n  res = (res >>> 21) |\n        (((res >> 14) & 0x7f) << 7) |\n        (((res >> 7) & 0x7f) << 14) |\n        ((res & 0x7f) << 21);\n  res >>= (4 - len) * 7;\n\n  // Append prefix max\n  res += max;\n\n  return res;\n};\n\nDecoder.prototype.decodeHuffmanWord = function decodeHuffmanWord(input,\n                                                                 inputBits,\n                                                                 out) {\n  var root = huffman;\n  var node = this._huffmanNode;\n  var word = input;\n  var bits = inputBits;\n\n  for (; bits > 0; word &= (1 << bits) - 1) {\n    // Nudge the word bit length to match it\n    for (var i = Math.max(0, bits - 8); i < bits; i++) {\n      var subnode = node[word >>> i];\n      if (typeof subnode !== 'number') {\n        node = subnode;\n        bits = i;\n        break;\n      }\n\n      if (subnode === 0)\n        continue;\n\n      // Word bit length should match\n      if ((subnode >>> 9) !== bits - i) {\n        subnode = 0;\n        continue;\n      }\n\n      var octet = subnode & 0x1ff;\n      assert(octet !== 256, 'EOS in encoding');\n      out.push(octet);\n      node = root;\n\n      bits = i;\n      break;\n    }\n    if (subnode === 0)\n      break;\n  }\n  this._huffmanNode = node;\n\n  return bits;\n};\n\nDecoder.prototype.decodeStr = function decodeStr() {\n  var isHuffman = this.decodeBit();\n  var len = this.decodeInt();\n  assert(this.buffer.has(len), 'Not enough octets for string');\n\n  if (!isHuffman)\n    return this.buffer.take(len);\n\n  this._huffmanNode = huffman;\n\n  var out = [];\n\n  var word = 0;\n  var bits = 0;\n  var lastKey = 0;\n  for (var i = 0; i < len; i++) {\n    word <<= 8;\n    word |= this.buffer.readUInt8();\n    bits += 8;\n\n    bits = this.decodeHuffmanWord(word, bits, out);\n    lastKey = word >> bits;\n    word &= (1 << bits) - 1;\n  }\n  assert(this._huffmanNode === huffman, '8-bit EOS');\n  assert(word + 1 === (1 << bits), 'Final sequence is not EOS');\n\n  this._huffmanNode = null;\n\n  return out;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}