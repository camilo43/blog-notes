{"ast":null,"code":"var assert = require('minimalistic-assert');\nvar Buffer = require('buffer').Buffer;\nfunction WBuf() {\n  this.buffers = [];\n  this.toReserve = 0;\n  this.size = 0;\n  this.maxSize = 0;\n  this.avail = 0;\n  this.last = null;\n  this.offset = 0;\n\n  // Used in slicing\n  this.sliceQueue = null;\n  this.forceReserve = false;\n\n  // Mostly a constant\n  this.reserveRate = 64;\n}\nmodule.exports = WBuf;\nWBuf.prototype.reserve = function reserve(n) {\n  this.toReserve += n;\n\n  // Force reservation of extra bytes\n  if (this.forceReserve) this.toReserve = Math.max(this.toReserve, this.reserveRate);\n};\nWBuf.prototype._ensure = function _ensure(n) {\n  if (this.avail >= n) return;\n  if (this.toReserve === 0) this.toReserve = this.reserveRate;\n  this.toReserve = Math.max(n - this.avail, this.toReserve);\n  if (this.avail === 0) this._next();\n};\nWBuf.prototype._next = function _next() {\n  var buf;\n  if (this.sliceQueue === null) {\n    // Most common case\n    buf = new Buffer(this.toReserve);\n  } else {\n    // Only for `.slice()` results\n    buf = this.sliceQueue.shift();\n    if (this.sliceQueue.length === 0) this.sliceQueue = null;\n  }\n  this.toReserve = 0;\n  this.buffers.push(buf);\n  this.avail = buf.length;\n  this.offset = 0;\n  this.last = buf;\n};\nWBuf.prototype._rangeCheck = function _rangeCheck() {\n  if (this.maxSize !== 0 && this.size > this.maxSize) throw new RangeError('WBuf overflow');\n};\nWBuf.prototype._move = function _move(n) {\n  this.size += n;\n  if (this.avail === 0) this.last = null;\n  this._rangeCheck();\n};\nWBuf.prototype.slice = function slice(start, end) {\n  assert(0 <= start && start <= this.size);\n  assert(0 <= end && end <= this.size);\n  if (this.last === null) this._next();\n  var res = new WBuf();\n\n  // Only last chunk is requested\n  if (start >= this.size - this.offset) {\n    res.buffers.push(this.last);\n    res.last = this.last;\n    res.offset = start - this.size + this.offset;\n    res.maxSize = end - start;\n    res.avail = res.maxSize;\n    return res;\n  }\n  var startIndex = -1;\n  var startOffset = 0;\n  var endIndex = -1;\n\n  // Find buffer indices\n  var offset = 0;\n  for (var i = 0; i < this.buffers.length; i++) {\n    var buf = this.buffers[i];\n    var next = offset + buf.length;\n\n    // Found the start\n    if (start >= offset && start <= next) {\n      startIndex = i;\n      startOffset = start - offset;\n      if (endIndex !== -1) break;\n    }\n    if (end >= offset && end <= next) {\n      endIndex = i;\n      if (startIndex !== -1) break;\n    }\n    offset = next;\n  }\n  res.last = this.buffers[startIndex];\n  res.offset = startOffset;\n  res.maxSize = end - start;\n\n  // Multi-buffer slice\n  if (startIndex < endIndex) {\n    res.sliceQueue = this.buffers.slice(startIndex + 1, endIndex + 1);\n    res.last = res.last.slice(res.offset);\n    res.offset = 0;\n  }\n  res.avail = res.last.length - res.offset;\n  res.buffers.push(res.last);\n  return res;\n};\nWBuf.prototype.skip = function skip(n) {\n  if (n === 0) return this.slice(this.size, this.size);\n  this._ensure(n);\n  var left = n;\n  while (left > 0) {\n    var toSkip = Math.min(left, this.avail);\n    left -= toSkip;\n    this.size += toSkip;\n    if (toSkip === this.avail) {\n      if (left !== 0) {\n        this._next();\n      } else {\n        this.avail -= toSkip;\n        this.offset += toSkip;\n      }\n    } else {\n      this.offset += toSkip;\n      this.avail -= toSkip;\n    }\n  }\n  this._rangeCheck();\n  return this.slice(this.size - n, this.size);\n};\nWBuf.prototype.write = function write(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    if (c > 255) len += 2;else len += 1;\n  }\n  this.reserve(len);\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    var hi = c >>> 8;\n    var lo = c & 0xff;\n    if (hi) this.writeUInt8(hi);\n    this.writeUInt8(lo);\n  }\n};\nWBuf.prototype.copyFrom = function copyFrom(buf, start, end) {\n  var off = start === undefined ? 0 : start;\n  var len = end === undefined ? buf.length : end;\n  if (off === len) return;\n  this._ensure(len - off);\n  while (off < len) {\n    var toCopy = Math.min(len - off, this.avail);\n    buf.copy(this.last, this.offset, off, off + toCopy);\n    off += toCopy;\n    this.size += toCopy;\n    if (toCopy === this.avail) {\n      if (off !== len) {\n        this._next();\n      } else {\n        this.avail = 0;\n        this.offset += toCopy;\n      }\n    } else {\n      this.offset += toCopy;\n      this.avail -= toCopy;\n    }\n  }\n  this._rangeCheck();\n};\nWBuf.prototype.writeUInt8 = function writeUInt8(v) {\n  this._ensure(1);\n  this.last[this.offset++] = v;\n  this.avail--;\n  this._move(1);\n};\nWBuf.prototype.writeUInt16BE = function writeUInt16BE(v) {\n  this._ensure(2);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 2) {\n    this.last.writeUInt16BE(v, this.offset);\n    this.offset += 2;\n    this.avail -= 2;\n\n    // One byte here, one byte there\n  } else {\n    this.last[this.offset] = v >>> 8;\n    this._next();\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n  }\n  this._move(2);\n};\nWBuf.prototype.writeUInt24BE = function writeUInt24BE(v) {\n  this._ensure(3);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 3) {\n    this.last.writeUInt16BE(v >>> 8, this.offset);\n    this.last[this.offset + 2] = v & 0xff;\n    this.offset += 3;\n    this.avail -= 3;\n    this._move(3);\n\n    // Two bytes here\n  } else if (this.avail >= 2) {\n    this.last.writeUInt16BE(v >>> 8, this.offset);\n    this._next();\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n    this._move(3);\n\n    // Just one byte here\n  } else {\n    this.last[this.offset] = v >>> 16;\n    this._move(1);\n    this._next();\n    this.writeUInt16BE(v & 0xffff);\n  }\n};\nWBuf.prototype.writeUInt32BE = function writeUInt32BE(v) {\n  this._ensure(4);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 4) {\n    this.last.writeUInt32BE(v, this.offset);\n    this.offset += 4;\n    this.avail -= 4;\n    this._move(4);\n\n    // Three bytes here\n  } else if (this.avail >= 3) {\n    this.writeUInt24BE(v >>> 8);\n    this._next();\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n    this._move(1);\n\n    // Slow case, who cares\n  } else {\n    this.writeUInt16BE(v >>> 16);\n    this.writeUInt16BE(v & 0xffff);\n  }\n};\nWBuf.prototype.writeUInt16LE = function writeUInt16LE(num) {\n  var r = (num & 0xff) << 8 | num >>> 8;\n  this.writeUInt16BE(r);\n};\nWBuf.prototype.writeUInt24LE = function writeUInt24LE(num) {\n  var r = (num & 0xff) << 16 | (num >>> 8 & 0xff) << 8 | num >>> 16;\n  this.writeUInt24BE(r);\n};\nWBuf.prototype.writeUInt32LE = function writeUInt32LE(num) {\n  this._ensure(4);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 4) {\n    this.last.writeUInt32LE(num, this.offset);\n    this.offset += 4;\n    this.avail -= 4;\n    this._move(4);\n\n    // Three bytes here\n  } else if (this.avail >= 3) {\n    this.writeUInt24LE(num & 0xffffff);\n    this._next();\n    this.last[this.offset++] = num >>> 24;\n    this.avail--;\n    this._move(1);\n\n    // Slow case, who cares\n  } else {\n    this.writeUInt16LE(num & 0xffff);\n    this.writeUInt16LE(num >>> 16);\n  }\n};\nWBuf.prototype.render = function render() {\n  var left = this.size;\n  var out = [];\n  for (var i = 0; i < this.buffers.length && left >= 0; i++) {\n    var buf = this.buffers[i];\n    left -= buf.length;\n    if (left >= 0) {\n      out.push(buf);\n    } else {\n      out.push(buf.slice(0, buf.length + left));\n    }\n  }\n  return out;\n};\n\n// Signed APIs\nWBuf.prototype.writeInt8 = function writeInt8(num) {\n  if (num < 0) return this.writeUInt8(0x100 + num);else return this.writeUInt8(num);\n};\nfunction toUnsigned16(num) {\n  if (num < 0) return 0x10000 + num;else return num;\n}\nWBuf.prototype.writeInt16LE = function writeInt16LE(num) {\n  this.writeUInt16LE(toUnsigned16(num));\n};\nWBuf.prototype.writeInt16BE = function writeInt16BE(num) {\n  this.writeUInt16BE(toUnsigned16(num));\n};\nfunction toUnsigned24(num) {\n  if (num < 0) return 0x1000000 + num;else return num;\n}\nWBuf.prototype.writeInt24LE = function writeInt24LE(num) {\n  this.writeUInt24LE(toUnsigned24(num));\n};\nWBuf.prototype.writeInt24BE = function writeInt24BE(num) {\n  this.writeUInt24BE(toUnsigned24(num));\n};\nfunction toUnsigned32(num) {\n  if (num < 0) return 0xffffffff + num + 1;else return num;\n}\nWBuf.prototype.writeInt32LE = function writeInt32LE(num) {\n  this.writeUInt32LE(toUnsigned32(num));\n};\nWBuf.prototype.writeInt32BE = function writeInt32BE(num) {\n  this.writeUInt32BE(toUnsigned32(num));\n};\nWBuf.prototype.writeComb = function writeComb(size, endian, value) {\n  if (size === 1) return this.writeUInt8(value);\n  if (endian === 'le') {\n    if (size === 2) this.writeUInt16LE(value);else if (size === 3) this.writeUInt24LE(value);else if (size === 4) this.writeUInt32LE(value);\n  } else {\n    if (size === 2) this.writeUInt16BE(value);else if (size === 3) this.writeUInt24BE(value);else if (size === 4) this.writeUInt32BE(value);\n  }\n};","map":{"version":3,"names":["assert","require","Buffer","WBuf","buffers","toReserve","size","maxSize","avail","last","offset","sliceQueue","forceReserve","reserveRate","module","exports","prototype","reserve","n","Math","max","_ensure","_next","buf","shift","length","push","_rangeCheck","RangeError","_move","slice","start","end","res","startIndex","startOffset","endIndex","i","next","skip","left","toSkip","min","write","str","len","c","charCodeAt","hi","lo","writeUInt8","copyFrom","off","undefined","toCopy","copy","v","writeUInt16BE","writeUInt24BE","writeUInt32BE","writeUInt16LE","num","r","writeUInt24LE","writeUInt32LE","render","out","writeInt8","toUnsigned16","writeInt16LE","writeInt16BE","toUnsigned24","writeInt24LE","writeInt24BE","toUnsigned32","writeInt32LE","writeInt32BE","writeComb","endian","value"],"sources":["/Users/juancvegao/Documents/PROGRAMMING/REACT/ejerciciosUniversidad/notes_github/frontend/node_modules/wbuf/index.js"],"sourcesContent":["var assert = require('minimalistic-assert');\nvar Buffer = require('buffer').Buffer;\n\nfunction WBuf() {\n  this.buffers = [];\n  this.toReserve = 0;\n  this.size = 0;\n  this.maxSize = 0;\n  this.avail = 0;\n\n  this.last = null;\n  this.offset = 0;\n\n  // Used in slicing\n  this.sliceQueue = null;\n\n  this.forceReserve = false;\n\n  // Mostly a constant\n  this.reserveRate = 64;\n}\nmodule.exports = WBuf;\n\nWBuf.prototype.reserve = function reserve(n) {\n  this.toReserve += n;\n\n  // Force reservation of extra bytes\n  if (this.forceReserve)\n    this.toReserve = Math.max(this.toReserve, this.reserveRate);\n};\n\nWBuf.prototype._ensure = function _ensure(n) {\n  if (this.avail >= n)\n    return;\n\n  if (this.toReserve === 0)\n    this.toReserve = this.reserveRate;\n\n  this.toReserve = Math.max(n - this.avail, this.toReserve);\n\n  if (this.avail === 0)\n    this._next();\n};\n\nWBuf.prototype._next = function _next() {\n  var buf;\n  if (this.sliceQueue === null) {\n    // Most common case\n    buf = new Buffer(this.toReserve);\n  } else {\n    // Only for `.slice()` results\n    buf = this.sliceQueue.shift();\n    if (this.sliceQueue.length === 0)\n      this.sliceQueue = null;\n  }\n\n  this.toReserve = 0;\n\n  this.buffers.push(buf);\n  this.avail = buf.length;\n  this.offset = 0;\n  this.last = buf;\n};\n\nWBuf.prototype._rangeCheck = function _rangeCheck() {\n  if (this.maxSize !== 0 && this.size > this.maxSize)\n    throw new RangeError('WBuf overflow');\n};\n\nWBuf.prototype._move = function _move(n) {\n  this.size += n;\n  if (this.avail === 0)\n    this.last = null;\n\n  this._rangeCheck();\n};\n\nWBuf.prototype.slice = function slice(start, end) {\n  assert(0 <= start && start <= this.size);\n  assert(0 <= end && end <= this.size);\n\n  if (this.last === null)\n    this._next();\n\n  var res = new WBuf();\n\n  // Only last chunk is requested\n  if (start >= this.size - this.offset) {\n    res.buffers.push(this.last);\n    res.last = this.last;\n    res.offset = start - this.size + this.offset;\n    res.maxSize = end - start;\n    res.avail = res.maxSize;\n\n    return res;\n  }\n\n  var startIndex = -1;\n  var startOffset = 0;\n  var endIndex = -1;\n\n  // Find buffer indices\n  var offset = 0;\n  for (var i = 0; i < this.buffers.length; i++) {\n    var buf = this.buffers[i];\n    var next = offset + buf.length;\n\n    // Found the start\n    if (start >= offset && start <= next) {\n      startIndex = i;\n      startOffset = start - offset;\n      if (endIndex !== -1)\n        break;\n    }\n    if (end >= offset && end <= next) {\n      endIndex = i;\n      if (startIndex !== -1)\n        break;\n    }\n\n    offset = next;\n  }\n\n  res.last = this.buffers[startIndex];\n  res.offset = startOffset;\n  res.maxSize = end - start;\n\n  // Multi-buffer slice\n  if (startIndex < endIndex) {\n    res.sliceQueue = this.buffers.slice(startIndex + 1, endIndex + 1);\n\n    res.last = res.last.slice(res.offset);\n    res.offset = 0;\n  }\n\n  res.avail = res.last.length - res.offset;\n  res.buffers.push(res.last);\n\n  return res;\n};\n\nWBuf.prototype.skip = function skip(n) {\n  if (n === 0)\n    return this.slice(this.size, this.size);\n\n  this._ensure(n);\n\n  var left = n;\n  while (left > 0) {\n    var toSkip = Math.min(left, this.avail);\n    left -= toSkip;\n    this.size += toSkip;\n    if (toSkip === this.avail) {\n      if (left !== 0) {\n        this._next();\n      } else {\n        this.avail -= toSkip;\n        this.offset += toSkip;\n      }\n    } else {\n      this.offset += toSkip;\n      this.avail -= toSkip;\n    }\n  }\n\n  this._rangeCheck();\n\n  return this.slice(this.size - n, this.size);\n};\n\nWBuf.prototype.write = function write(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    if (c > 255)\n      len += 2;\n    else\n      len += 1;\n  }\n  this.reserve(len);\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    var hi = c >>> 8;\n    var lo = c & 0xff;\n\n    if (hi)\n      this.writeUInt8(hi);\n    this.writeUInt8(lo);\n  }\n};\n\nWBuf.prototype.copyFrom = function copyFrom(buf, start, end) {\n  var off = start === undefined ? 0 : start;\n  var len = end === undefined ? buf.length : end;\n  if (off === len)\n    return;\n\n  this._ensure(len - off);\n  while (off < len) {\n    var toCopy = Math.min(len - off, this.avail);\n    buf.copy(this.last, this.offset, off, off + toCopy);\n    off += toCopy;\n    this.size += toCopy;\n    if (toCopy === this.avail) {\n      if (off !== len) {\n        this._next();\n      } else {\n        this.avail = 0;\n        this.offset += toCopy;\n      }\n    } else {\n      this.offset += toCopy;\n      this.avail -= toCopy;\n    }\n  }\n\n  this._rangeCheck();\n};\n\nWBuf.prototype.writeUInt8 = function writeUInt8(v) {\n  this._ensure(1);\n\n  this.last[this.offset++] = v;\n  this.avail--;\n  this._move(1);\n};\n\nWBuf.prototype.writeUInt16BE = function writeUInt16BE(v) {\n  this._ensure(2);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 2) {\n    this.last.writeUInt16BE(v, this.offset);\n    this.offset += 2;\n    this.avail -= 2;\n\n  // One byte here, one byte there\n  } else {\n    this.last[this.offset] = (v >>> 8);\n    this._next();\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n  }\n\n  this._move(2);\n};\n\nWBuf.prototype.writeUInt24BE = function writeUInt24BE(v) {\n  this._ensure(3);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 3) {\n    this.last.writeUInt16BE(v >>> 8, this.offset);\n    this.last[this.offset + 2] = v & 0xff;\n    this.offset += 3;\n    this.avail -= 3;\n    this._move(3);\n\n  // Two bytes here\n  } else if (this.avail >= 2) {\n    this.last.writeUInt16BE(v >>> 8, this.offset);\n    this._next();\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n    this._move(3);\n\n  // Just one byte here\n  } else {\n    this.last[this.offset] = v >>> 16;\n    this._move(1);\n    this._next();\n    this.writeUInt16BE(v & 0xffff);\n  }\n};\n\nWBuf.prototype.writeUInt32BE = function writeUInt32BE(v) {\n  this._ensure(4);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 4) {\n    this.last.writeUInt32BE(v, this.offset);\n    this.offset += 4;\n    this.avail -= 4;\n    this._move(4);\n\n  // Three bytes here\n  } else if (this.avail >= 3) {\n    this.writeUInt24BE(v >>> 8);\n    this._next();\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n    this._move(1);\n\n  // Slow case, who cares\n  } else {\n    this.writeUInt16BE(v >>> 16);\n    this.writeUInt16BE(v & 0xffff);\n  }\n};\n\nWBuf.prototype.writeUInt16LE = function writeUInt16LE(num) {\n  var r = ((num & 0xff) << 8) | (num >>> 8);\n  this.writeUInt16BE(r);\n};\n\nWBuf.prototype.writeUInt24LE = function writeUInt24LE(num) {\n  var r = ((num & 0xff) << 16) | (((num >>> 8) & 0xff) << 8) | (num >>> 16);\n  this.writeUInt24BE(r);\n};\n\nWBuf.prototype.writeUInt32LE = function writeUInt32LE(num) {\n  this._ensure(4);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 4) {\n    this.last.writeUInt32LE(num, this.offset);\n    this.offset += 4;\n    this.avail -= 4;\n    this._move(4);\n\n  // Three bytes here\n  } else if (this.avail >= 3) {\n    this.writeUInt24LE(num & 0xffffff);\n    this._next();\n    this.last[this.offset++] = num >>> 24;\n    this.avail--;\n    this._move(1);\n\n  // Slow case, who cares\n  } else {\n    this.writeUInt16LE(num & 0xffff);\n    this.writeUInt16LE(num >>> 16);\n  }\n};\n\nWBuf.prototype.render = function render() {\n  var left = this.size;\n  var out = [];\n\n  for (var i = 0; i < this.buffers.length && left >= 0; i++) {\n    var buf = this.buffers[i];\n    left -= buf.length;\n    if (left >= 0) {\n      out.push(buf);\n    } else {\n      out.push(buf.slice(0, buf.length + left));\n    }\n  }\n\n  return out;\n};\n\n// Signed APIs\nWBuf.prototype.writeInt8 = function writeInt8(num) {\n  if (num < 0)\n    return this.writeUInt8(0x100 + num);\n  else\n    return this.writeUInt8(num);\n};\n\nfunction toUnsigned16(num) {\n  if (num < 0)\n    return 0x10000 + num;\n  else\n    return num;\n}\n\nWBuf.prototype.writeInt16LE = function writeInt16LE(num) {\n  this.writeUInt16LE(toUnsigned16(num));\n};\n\nWBuf.prototype.writeInt16BE = function writeInt16BE(num) {\n  this.writeUInt16BE(toUnsigned16(num));\n};\n\nfunction toUnsigned24(num) {\n  if (num < 0)\n    return 0x1000000 + num;\n  else\n    return num;\n}\n\nWBuf.prototype.writeInt24LE = function writeInt24LE(num) {\n  this.writeUInt24LE(toUnsigned24(num));\n};\n\nWBuf.prototype.writeInt24BE = function writeInt24BE(num) {\n  this.writeUInt24BE(toUnsigned24(num));\n};\n\nfunction toUnsigned32(num) {\n  if (num < 0)\n    return (0xffffffff + num) + 1;\n  else\n    return num;\n}\n\nWBuf.prototype.writeInt32LE = function writeInt32LE(num) {\n  this.writeUInt32LE(toUnsigned32(num));\n};\n\nWBuf.prototype.writeInt32BE = function writeInt32BE(num) {\n  this.writeUInt32BE(toUnsigned32(num));\n};\n\nWBuf.prototype.writeComb = function writeComb(size, endian, value) {\n  if (size === 1)\n    return this.writeUInt8(value);\n\n  if (endian === 'le') {\n    if (size === 2)\n      this.writeUInt16LE(value);\n    else if (size === 3)\n      this.writeUInt24LE(value);\n    else if (size === 4)\n      this.writeUInt32LE(value);\n  } else {\n    if (size === 2)\n      this.writeUInt16BE(value);\n    else if (size === 3)\n      this.writeUInt24BE(value);\n    else if (size === 4)\n      this.writeUInt32BE(value);\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}